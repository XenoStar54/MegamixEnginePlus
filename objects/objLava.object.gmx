<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprLava</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>sprSolid</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// modelled after MM7 and MM8 lava
// junk and physics blocks sink in it
// instakills things
// when frozen, can be stood on
event_inherited();

blockCollision = 0;
grav = 0;
inWater = -1;
bubbleTimer = -1;
despawnRange = -1;
respawnRange = -1;
shiftVisible = 3;
faction = 4;
contactDamage = 7;
isSolid = 0;
canHit = false;
canDamage = true;
stopOnFlash = false;

//@cc: speed with which physics blocks move in lava
// positive value = clockwise movement
// negative value = counterclockwise movement
flowSpd = 0;
// heavy blocks will move with half the speed

//@cc: when true, lava will break apart when frozen
crumbles = false;

//@cc: how long the non-crumbling lava is frozen; set to -1 to have it be permament
freezeTimer = 600;

//@cc: when true, the lava will be solid anyway 
solidAnyway = 0;
fnsolidWhenNotFrozen = 1;
spikeBehaviorWhenNotFrozen = 0;

var index = 0;
//@cc: list of objects that can freeze lava
freezesMe[index++] = objIceSlasher;
freezesMe[index++] = objIceSlasherGB;
freezesMe[index++] = objIcicle;
freezesMe[index++] = objAuAuShot;

index = 0;
//@cc: list of objects that sink in lava
sinks[index++] = objJunkBlock;
sinks[index++] = objXBlock;
sinks[index++] = objReflectBlockSmall;

index = 0;
//@cc: list of objects that sink in lava but faster
sinksHeavy[index++] = objReflectBlockLarge;

sinkSpd = 0.2;
heavySinkSpd = 0.4;

crumbleTimer = 0;
crumbleTimerMax = 60;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if(!global.frozen &amp;&amp; !dead &amp;&amp; !(global.timeStopped &amp;&amp; stopOnFlash))
{
    for(var i = 0; i &lt; array_length_1d(freezesMe); i++)
    {
        if(instance_exists(freezesMe[i]) &amp;&amp; place_meeting(x,y,freezesMe[i]))
        {
            if(freezeTimer &lt; 0) entityIceFreeze(power(2,32)-1);
            else entityIceFreeze(freezeTimer);
            isSolid = 1;
            canDamage = false;
        }
    }
    
    if(iceTimer &gt; 0) // frozen
    {
        if(freezeTimer &lt; 0) iceTimer = power(2,32)-1;
        isSolid = 1;
        canDamage = false;
        entitySpike = false;
        fnsolid = 0;
        with(objLava) if(iceTimer &lt;= 0) // keep surrounding lava frozen
        {
            if(collision_rectangle(bbox_left-1,bbox_top,bbox_right+2,bbox_bottom,other,0,1) ||
                collision_rectangle(bbox_left,bbox_top-1,bbox_right,bbox_bottom+2,other,0,1))
            {
                entityIceFreeze(other.iceTimer);
                isSolid = 1;
                canDamage = false;
            }
        }
        
        // crumble like the lava falls in MM7
        if(crumbles)
        {
            crumbleTimer++;
            if(crumbleTimer &gt; crumbleTimerMax)
            {
                event_user(10);
            }
        }
    }
    else // not frozen: carry physics blocks etc.
    {
        isSolid = solidAnyway;
        canDamage = true;
        crumbleTimer = 0;
        entitySpike = spikeBehaviorWhenNotFrozen;
        fnsolid = fnsolidWhenNotFrozen;
    }
    
    for(var i = 0; i &lt; array_length_1d(sinks); i++)
    {
        with(sinks[i])
        {
            if(place_meeting(x,y,other) || place_meeting(x,y+sign(yspeed)*0.5*sprite_height,other))
            {
                if(other.iceTimer &gt; 0)
                {
                    if(place_meeting(x,y,other))
                    {
                        xspeed = 0;
                        yspeed = -grav;
                    }
                }
                else
                {
                    if(abs(yspeed) &gt; 2) yspeed -= (grav*5);
                    else if(abs(yspeed) &gt; 1) yspeed -= (grav*2);
                    else if(abs(yspeed) &gt; other.sinkSpd) yspeed -= (grav*1.5);
                    else yspeed = sign(grav)*other.sinkSpd - grav;
                    shiftObject(other.flowSpd*sign(grav),0,blockCollision);
                }
            }
        }
    }
    for(var i = 0; i &lt; array_length_1d(sinksHeavy); i++)
    {
        with(sinksHeavy[i])
        {
            if(place_meeting(x,y,other) || place_meeting(x,y+sign(yspeed)*0.5*sprite_height,other))
            {
                if(other.iceTimer &gt; 0)
                {
                    if(place_meeting(x,y,other))
                    {
                        xspeed = 0;
                        yspeed = -grav;
                    }
                }
                else
                {
                    if(abs(yspeed) &gt; 2) yspeed -= (grav*5);
                    else if(abs(yspeed) &gt; 1) yspeed -= (grav*2);
                    else if(abs(yspeed) &gt; other.heavySinkSpd) yspeed -= (grav*1.5);
                    else yspeed = sign(grav)*other.heavySinkSpd - grav;
                    shiftObject(other.flowSpd*sign(grav)*0.5,0,blockCollision);
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dead = 1;

for(var i = 0; i &lt; abs(image_xscale); i++) for(var j = 0; j &lt; abs(image_yscale); j++)
{
    var crack = instance_create(bbox_left+(i+0.5)*16,bbox_top+(j+0.5)*16,objSlashEffect);
    crack.sprite_index = sprFreezeBreakPlatformBits;
    crack.image_index = 2;
    crack.image_speed = 0;
    crack.image_angle = choose(0,180);
    crack.image_xscale = choose(-1,1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
