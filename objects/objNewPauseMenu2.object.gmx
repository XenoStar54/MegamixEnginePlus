<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprNewPauseMenu</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2001</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.nextRoom = -1;
visible = 0;

phase = 0; // 0: increasing the black rectangle's alpha

option = 0;
itemRow = 0;
oldOption = 0;
weaponOffset = 0;
offsetTimer = -1;

pauseRow = 0
pauseRowOption = 0

image_index = 0;
image_speed = 0;

// get currently visible weapons
weaponVisibleN = 0;
for (var i = 0; i &lt;= global.totalWeapons; i++)
{
    if (global.weaponLocked[global.weaponHotbar[i]] &lt; 2)
    {
        weaponVisible[weaponVisibleN++] = i;
    }
}
/*visibleWeapons = min(10, weaponVisibleN); // up to 10 visible

for (var i = 0; i &lt; weaponVisibleN; i++)
{
    if (global.weapon[0] == global.weaponHotbar[weaponVisible[i]])
    {
        option = i;
        oldOption = i;
    }
}*/
//woption = i;

weaponX = 0
weaponY = 0
weaponPage = 0
weaponPageMax = ceil(global.totalWeapons/12);

for (var i = weaponPage*12; i &lt; weaponVisibleN; i++){
    weaponSlot[i mod 6, floor(i/6)] = weaponVisible[i];
}
/*
//Row 0
weaponSlot[0,0] = 0
weaponSlot[0,1] = 1

//Row 1
weaponSlot[1,0] = 2
weaponSlot[1,1] = 3

//Row 2
weaponSlot[2,0] = 4
weaponSlot[2,1] = 5

//Row 3
weaponSlot[3,0] = 6
weaponSlot[3,1] = 7

//Row 4
weaponSlot[4,0] = 8
weaponSlot[4,1] = 9

//Row 5
weaponSlot[5,0] = 10
weaponSlot[5,1] = 11
*/
itemOption = 1

visibleWeapons = 12;

oldWeapon = global.weapon[0];
resetWeapon = false; // Should we, after exiting the menu, reset our weapon to the weapon that was used before the pause menu was opened?

wtank = 0;
mtank = 0;

retryConfirm = 0;
exitConfirm = 0;
hotBarArrangeMode = false;

playerID = 0;
costumeID = 0;

// Stop charging
with (objMegaman)
{
    playerPalette();
}

// set these here. makes everyone's lives easier.

etankPositionX = 148;
etankPositionY = 10;
wtankPositionX = 178;
wtankPositionY = 10;
mtankPositionX = 210;
mtankPositionY = 10;

optionsPositionX = 136;
optionsPositionY = 208;
checkPositionX = 158;
checkPositionY = 208;
exitPositionX = 204;
exitPositionY = 208;

arrowTimer = 20;

quickScrollTimer = 0; // 24;

bgTimer = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Can't control while options menu is open
if (instance_exists(objOptionsMenu))
{
    exit;
}

bgTimer++;

// do pause menu
switch (phase)
{
    // Fading out
    case 0:
        with (objGlobalControl)
        {
            if (fadeAlpha == 1)
            {
                global.nextRoom = 0;
                other.visible = 1;
                other.phase = 1;
                showhealth = 0;
            }
        }
        break;
    
    // Fading in
    case 1:
        with (objGlobalControl)
        {
            if (fadeAlpha == 0)
            {
                other.phase = 2;
            }
        }
        event_user(0); // Moving the selection
        
        break;
    
    // Idle
    case 2:
        event_user(0); // Moving the selection
        
        // Select the weapon/tank
        if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
        {
            if (itemRow == 0 &amp;&amp; pauseRow == 0)
            {
                if (instance_exists(objMegaman.vehicle) &amp;&amp; weaponSlot[weaponX,weaponY] != 0)
                {
                    if (!objMegaman.vehicle.weaponsAllowed)
                    {
                        playSFX(sfxError);
                        exit;
                    }
                }
                if (global.weaponLocked[weaponSlot[weaponX,weaponY]])
                {
                    playSFX(sfxError);
                    exit;
                }
                
                global.nextRoom = -1;
                phase = 3;
                
                global.weapon[playerID] = weaponSlot[weaponX,weaponY];
                playSFX(sfxMenuSelect);
            }
            else if (itemOption == 1 &amp;&amp; itemRow == 1 &amp;&amp; pauseRow == 0) // E-Tank
            {
                if (global.eTanks &amp;&amp; global.playerHealth[playerID] &lt; 28)
                {
                    option = 0; // Nothing selected
                    phase = 5;
                    wtank = 0;
                    mtank = 0;
                    global.eTanks -= 1;
                    eTankTimer = 0;
                    playSFX(sfxEnergyRestore, true);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (itemOption == 2 &amp;&amp; itemRow == 1 &amp;&amp; pauseRow == 0) // W-Tank
            {
                // Check if weapon energy actually needs filling
                var proceed;
                proceed = false;
                for (i = 0; i &lt; global.totalWeapons; i += 1)
                {
                    if (ceil(global.ammo[playerID, i]) &lt; 28)
                    {
                        proceed = true;                        
                        itemRow = 0;
                        pauseRow = 0;
                    }
                }
                
                if (global.wTanks &amp;&amp; proceed)
                {
                    option = 0; // Go back to weapon column
                    phase = 6;
                    mtank = 0;
                    wtank = 1;
                    global.wTanks -= 1;
                    playSFX(sfxMenuSelect);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (itemOption == 3 &amp;&amp; itemRow == 1 &amp;&amp; pauseRow == 0) // M-Tank
            {
                if (global.mTanks &gt; 0) // Check if health or weapon energy actually needs filling
                {
                    var proceed = false;
                    for (i = 0; i &lt; global.totalWeapons; i += 1)
                    {
                        if (ceil(global.ammo[playerID, i]) &lt; 28)
                        {
                            proceed = true;                      
                            itemRow = 0;
                            pauseRow = 0;
                        }
                    }
                    
                    if (ceil(global.playerHealth[playerID]) &lt; 28)
                    {
                        proceed = true;                      
                        itemRow = 0;
                        pauseRow = 0;
                    }
                    
                    if (proceed) // If proceed is still false after the past calculations, it seems there is nothing to fill
                    {
                        option = 0; // Nothing selected
                        phase = 5;
                        mtank = 1;
                        wtank = 0;
                        global.mTanks -= 1;
                        eTankTimer = 0;
                        playSFX(sfxEnergyRestore, true);
                    }
                    else
                    {
                        playSFX(sfxError);
                    }
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (pauseRow == 1 &amp;&amp; pauseRowOption == 0) // Weapons
            {
                itemRow = 0
                playSFX(sfxMenuSelect);
                exit;
            }
            else if (pauseRow == 1 &amp;&amp; pauseRowOption == 1) // Items
            {
                itemRow = 1
                playSFX(sfxMenuSelect);
                exit;
            }
            else if (pauseRow == 1 &amp;&amp; pauseRowOption == 2) // Options
            {
                instance_create(x, y, objOptionsMenu);
                playSFX(sfxMenuSelect);
                exit;
            }
            else if (pauseRow == 1 &amp;&amp; pauseRowOption == 3) // Retry
            {
                if (!retryConfirm)
                {
                    retryConfirm = true;
                    playSFX(sfxMenuSelect);
                    exit;
                }
            }
            else if (pauseRow == 1 &amp;&amp; pauseRowOption == 4) // Exit
            {
                if (!exitConfirm)
                {
                    exitConfirm = true;
                    playSFX(sfxMenuSelect);
                    exit;
                }
            }
        }
        
        // Confirming exit
        if (exitConfirm &amp;&amp; !global.nextRoom)
        {
            if (pauseRow == 1 &amp;&amp; pauseRowOption == 4)
            {
                if (global.keyJumpPressed[playerID]
                    || global.keyPausePressed[playerID])
                {
                    returnFromLevel();
                    playSFX(sfxMenuSelect);
                }
            }
            else
            {
                exitConfirm = false;
            }
        }
        
        // Confirming retry
        if (retryConfirm &amp;&amp; !global.nextRoom)
        {
            if (pauseRow == 1 &amp;&amp; pauseRowOption == 3)
            {
                if (global.keyJumpPressed[playerID]
                    || global.keyPausePressed[playerID])
                {
                    global.nextRoom = room;
                    playSFX(sfxMenuSelect);
                }
            }
            else
            {
                retryConfirm = false;
            }
        }
        
        break;
    
    // Fading out
    case 3:
        with (objGlobalControl)
        {
            if (fadeAlpha == 1 &amp;&amp; global.nextRoom != 0)
            {
                showhealth = 1;
                with (other)
                {
                    if (resetWeapon)
                    {
                        global.weapon[playerID] = oldWeapon;
                        with (objMegaman)
                        {
                            playerPalette();
                        }
                    }
                    
                    if (global.weapon[playerID] != oldWeapon)
                    {
                        with (prtPlayerProjectile)
                        {
                            instance_destroy();
                        }
                    }
                    
                    global.nextRoom = 0;
                    visible = 0;
                }
            }
            else if (fadeAlpha == 0 &amp;&amp; global.nextRoom == 0)
            {
                with (other)
                {
                    audio_resume_all();
                    instance_destroy();
                    global.frozen = 0;
                }
            }
        }
        
        break;
    
    // E/M-Tank restoring health
    case 5:
        eTankTimer += 1;
        if (eTankTimer &gt;= 3)
        {
            eTankTimer = 0;
            
            var proceed;
            proceed = false;
            
            // Fill selected weapon w/ W Tank
            if (wtank)
            {
                if (global.ammo[playerID, weaponSlot[weaponX,weaponY]] &lt; 28)
                {
                    global.ammo[playerID, weaponSlot[weaponX,weaponY]] = min(28,
                        global.ammo[playerID, weaponSlot[weaponX,weaponY]] + 1);
                    proceed = true;
                }
            }
            
            // Fill all weapons - M-Tank only
            if (mtank)
            {
                for (i = 1; i &lt; global.totalWeapons; i += 1)
                {
                    if (global.ammo[playerID, i] &lt; 28)
                    {
                        global.ammo[playerID, i] = min(28,
                            global.ammo[playerID, i] + 1);
                        proceed = true;
                    }
                }
            }
            
            // Fill health
            if ((global.playerHealth[playerID] &lt; 28) &amp;&amp; (!wtank))
            {
                global.playerHealth[playerID] = min(28,
                    global.playerHealth[playerID] + 1);
                proceed = true;
            }
            
            if (!proceed)
            {
                eTankTimer = 0;
                phase = 2;
                if (!wtank)
                {
                    option = oldOption;
                    global.weapon[playerID] = oldWeapon;
                    with (objMegaman)
                    {
                        playerPalette();
                    }
                }
                
                audio_stop_sound(sfxEnergyRestore);
            }
        }
        
        break;
    
    // W-Tank weapon selection
    case 6:
        event_user(0); // Moving the selection
        
            if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
            {
                if (global.ammo[playerID, weaponSlot[weaponX,weaponY]] &lt; 28)
                {
                    phase = 5;
                    eTankTimer = 0;
                    playSFX(sfxEnergyRestore, true);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
        
        break;
}

// update stored player sprite
if (instance_exists(objMegaman))
{
    with (objMegaman)
    {
        if (playerID == other.playerID)
        {
            other.costumeID = costumeID;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Weapon Pages
/*
for (var p = 0; p &lt;= weaponPageMax; p++){
    for (var i = 0; i &lt;= visibleWeapons/2; i++){
        for (var j = 0; j &lt; 1; j++){
            var w = 10*p + i + j;
            if (w &lt;= global.totalWeapons){
                show_debug_message(w);
                weaponSlot[i, j] = w;
            }
        }
    }
}
*/
for (var i = 0; i &lt; visibleWeapons; i++){
    var w = i + weaponPage*visibleWeapons;
    if (w &lt; weaponVisibleN){
        weaponSlot[i mod 6, floor(i/6)] = weaponVisible[w];
        show_debug_message("X,Y,PAGE = " + string(i mod 6) + "," + string(floor(i/6)) + "," + string(w))
    }
    else{
        weaponSlot[i mod 6, floor(i/6)] = -1;
    }
}
/*
switch (weaponPage)
{
    case 0:
        weaponSlot[0,0] = 0
        weaponSlot[0,1] = 1
        weaponSlot[1,0] = 2
        weaponSlot[1,1] = 3
        weaponSlot[2,0] = 4
        weaponSlot[2,1] = 5
        weaponSlot[3,0] = 6
        weaponSlot[3,1] = 7
        weaponSlot[4,0] = 8
        weaponSlot[4,1] = 9
        weaponSlot[5,0] = 10
        weaponSlot[5,1] = 11
        break;
    case 1:
        weaponSlot[0,0] = 12
        weaponSlot[0,1] = 13
        weaponSlot[1,0] = 14
        weaponSlot[1,1] = 15
        weaponSlot[2,0] = 16
        weaponSlot[2,1] = 17
        weaponSlot[3,0] = 18
        weaponSlot[3,1] = 19
        weaponSlot[4,0] = 20
        weaponSlot[4,1] = 21
        weaponSlot[5,0] = 22
        weaponSlot[5,1] = 23
        break;
}*
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hotBarArrangeMode = 0;//(global.keyShoot[playerID]) * (hotBarArrangeMode + 1);

var xDir = (global.keyRightPressed[playerID] - global.keyLeftPressed[playerID]);

var yDir = (global.keyDownPressed[playerID] - global.keyUpPressed[playerID]);
//((global.keyDownPressed[playerID] || (global.keyDown[playerID] &amp;&amp; quickScrollTimer &lt;= 0))
    //- (global.keyUpPressed[playerID] || (global.keyUp[playerID] &amp;&amp; quickScrollTimer &lt;= 0)));

if (xDir != 0)
{
    playSFX(sfxMenuMove);
    if weaponY = 0 &amp;&amp; pauseRow == 0
    {
        weaponY = 1;
        show_debug_message(string(weaponSlot[weaponX,weaponY]));
        if (weaponSlot[weaponX,weaponY] &gt; global.totalWeapons - 1 || weaponSlot[weaponX,weaponY] == -1){
            weaponY = 0;
        }
    }
    else if weaponY = 1 &amp;&amp; pauseRow == 0
    {
        weaponY = 0;
        show_debug_message(string(weaponSlot[weaponX,weaponY]));
        if (weaponSlot[weaponX,weaponY] &gt; global.totalWeapons - 1 || weaponSlot[weaponX,weaponY] == -1){
            weaponY = 1;
        }
    }
    
    if xDir = -1 &amp;&amp; pauseRow == 1 &amp;&amp; pauseRowOption = 0
    {
        pauseRowOption = 4
    }
    else if xDir = 1 &amp;&amp; pauseRow == 1 &amp;&amp; pauseRowOption = 4
    {
        pauseRowOption = 0
    }
    else pauseRowOption += xDir
    
    
        if ((itemOption == 1 &amp;&amp; xDir &lt; 0))
        {
            itemOption = 3;
        }
        else if ((itemOption == 3 &amp;&amp; xDir &gt; 0))
        {
            itemOption = 1;
        }
        else
        {
            itemOption += xDir;
        }
}
if (yDir != 0)
{
    playSFX(sfxMenuMove);
    if yDir = -1 &amp;&amp; weaponX = 0 &amp;&amp; pauseRow == 0
    {
        weaponX = 5
        if (weaponSlot[weaponX,weaponY] &gt; global.totalWeapons - 1 || weaponSlot[weaponX,weaponY] == -1){
            weaponX = 0;
        }
    }
    else if yDir = 1 &amp;&amp; weaponX = 5 &amp;&amp; pauseRow == 0
    {
        if phase != 6
        {
            pauseRow = 1
            weaponX = 0
            if (weaponSlot[weaponX,weaponY] &gt; global.totalWeapons - 1 || weaponSlot[weaponX,weaponY] == -1){
                weaponX = 5;
            }
            pauseRowOption = 0
        }
    }
    else if yDir = -1 &amp;&amp; pauseRow == 1
    {
        pauseRow = 0
        itemOption = 1
        weaponX = 5
        if (weaponSlot[weaponX,weaponY] &gt; global.totalWeapons - 1 || weaponSlot[weaponX,weaponY] == -1){
            weaponX = 0;
        }
        weaponY = 0
    }
    else if yDir = 1 &amp;&amp; pauseRow == 1
    {
        pauseRow = 0
        itemOption = 1
        weaponX = 5
        if (weaponSlot[weaponX,weaponY] &gt; global.totalWeapons - 1 || weaponSlot[weaponX,weaponY] == -1){
            weaponX = 0;
        }
        weaponY = 0
    }
    else{
        weaponX += yDir
        if (weaponSlot[weaponX,weaponY] &gt; global.totalWeapons - 1 || weaponSlot[weaponX,weaponY] == -1){
            weaponX -= yDir;
        }
    }
    
    if yDir = 1 &amp;&amp; pauseRow == 0 &amp;&amp; itemRow == 1
    {        
        pauseRow = 1 
    }
}

if ((global.keyWeaponSwitchLeftPressed[playerID] || global.keyWeaponSwitchRightPressed[playerID]))
{

    var change = global.keyWeaponSwitchRightPressed[playerID] - global.keyWeaponSwitchLeftPressed[playerID];
    playSFX(sfxUnlocked);
    
    if (weaponPage == 0 &amp;&amp; change &lt; 0) // horizontal movements while on the weapon list
    {
        weaponPage = weaponPageMax - 1;
    }
    else if (weaponPage &gt;= weaponPageMax - 1 &amp;&amp; change &gt; 0) // horizontal movements while on the misc selections
    {
        weaponPage = 0;
    }
    else{
        weaponPage += change;
    }
}

if global.keyShootPressed[playerID]
{
    if phase == 6
    {
        playSFX(sfxUnlocked);
        phase = 2
        global.wTanks++
    }
}

// do quick scroll timer

// Set weapon
//global.weapon[playerID] = 0;
if weaponSlot[weaponX,weaponY] &lt;= global.totalWeapons - 1 &amp;&amp; weaponSlot[weaponX, weaponY] &gt; -1
{
    global.weapon[playerID] = weaponSlot[weaponX,weaponY];
}
else{
    weaponX = 0;
    weaponY = 0;
}

with (objMegaman)
{
    playerPalette();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// center in screen on nonstandard resolutions
x = view_xview + (view_wview[0] - 256) / 2;
y = view_yview + (view_hview[0] - 224) / 2;

draw_sprite_ext(sprDot, 0, view_xview, view_yview, view_wview, view_hview, 0, c_black, 1);

// Menu
if (phase != 0)
{
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_white);
    //draw_clear(c_black);
    
    var col;
    /*col[0, 0] = global.nesPalette[0];
    col[1, 0] = global.nesPalette[13];
    col[0, 1] = global.primaryCol[0];
    col[1, 1] = global.secondaryCol[0];
    col[0, 2] = make_color_rgb(255, 228, 164);
    col[1, 2] = c_white;*/
    
    col[0] = c_black;
    col[1] = global.primaryCol[playerID];
    col[2] = global.secondaryCol[playerID];
    if (color_get_red(col[2]) &gt; 242 &amp;&amp; color_get_blue(col[2]) &gt; 242 &amp;&amp; color_get_green(col[2]) &gt; 242){
        col[2] = global.nesPalette[13];
    }
    if (color_get_red(col[1]) &gt; 242 &amp;&amp; color_get_blue(col[1]) &gt; 242 &amp;&amp; color_get_green(col[1]) &gt; 242){
        col[1] = global.nesPalette[13];
        col[2] = global.primaryCol[playerID];
    }
    col[3] = c_white;
    
    //color setup
    var pColP = 0;
    var pColS = 0;
    
    switch(costumeID){
        default:
            pColP = global.nesPalette[14];
            pColS = global.nesPalette[27];
        break;
    }
    
    var colP, colS;
    if (global.weaponPrimaryColor[global.weapon[playerID]] == -1 || global.weaponPrimaryColor[global.weapon[playerID]] == -2 || global.weaponPrimaryColor[global.weapon[playerID]] == -3){
        colP = pColP;
        colS = pColS;
    }
    else{
        colP = global.weaponPrimaryColor[global.weapon[playerID]];
        colS = global.weaponSecondaryColor[global.weapon[playerID]];
        if (color_get_red(colS) &gt; 242 &amp;&amp; color_get_blue(colS) &gt; 242 &amp;&amp; color_get_green(colS) &gt; 242){
            colS = global.nesPalette[13];
        }
        if (color_get_red(colP) &gt; 242 &amp;&amp; color_get_blue(colP) &gt; 242 &amp;&amp; color_get_green(colP) &gt; 242){
            colP = global.nesPalette[13];
            colS = global.weaponPrimaryColor[global.weapon[playerID]];
        }
    }
    
    // NOW draw itself
    drawSelf();
    for (var i = 0; i &lt; 3; i++){
        if (i == 0){
            draw_sprite_ext(sprite_index, i, round(x), round(y), image_xscale, image_yscale, image_angle, c_white, 1);
        }
        else{
            draw_sprite_ext(sprite_index, i, round(x), round(y), image_xscale, image_yscale, image_angle, col[i], 1);
        }
    }
    
    for (var i = 0; i &lt; 3; i++){
        for (j = -1; j &lt; 15; j++){
            if (i == 0){
                draw_sprite_ext(sprMMDAPauseGrid, i, round(x), y + floor((bgTimer mod 128)/8 + 16*j), 1, 1, 0, c_white, 1);
                draw_sprite_ext(sprMMDAPauseGrid, i, round(x + 16*15), y + floor((bgTimer mod 128)/8 + 16*j), 1, 1, 0, c_white, 1);
            }
            else{
                draw_sprite_ext(sprMMDAPauseGrid, i, round(x), y + floor((bgTimer mod 128)/8 + 16*j), 1, 1, 0, col[i], 1);
                draw_sprite_ext(sprMMDAPauseGrid, i, round(x + 16*15), y + floor((bgTimer mod 128)/8 + 16*j), 1, 1, 0, col[i], 1);
            }
        }
    }

    if itemRow == 0
    {    
        draw_set_color(c_white);
        draw_set_halign(fa_center);
        draw_text(x + 16*8, y + 16*5 - 8, "WEAPONS");
        draw_set_halign(fa_left);
        //Draw weapons
        for (var i = 0; i &lt; visibleWeapons; i++){
            if (weaponSlot[i mod 6, floor(i/6)] &lt; global.totalWeapons &amp;&amp; weaponSlot[i mod 6, floor(i/6)] != -1)
            {
                var X = 48 + floor(i/6)*86;
                var Y = 86 + 17*(i mod 6);
                drawPauseMenuWeapon(weaponSlot[i mod 6, floor(i/6)], i mod 6, floor(i/6), X, Y, X + 18, Y + 8, X + 18, Y, (i == 0));
            }
        }
        for (var i = 0; i &lt; 3; i++){
            if (i == 0){
                draw_sprite_ext(sprMMDAPauseArrow, i, x + 32 + 7, y + 16*8.5, -1, 1, 0, c_white, 1);
                draw_sprite_ext(sprMMDAPauseArrow, i, x - 32 - 7 + 16*16, y + 16*8.5, 1, 1, 0, c_white, 1);
            }
            else{
                draw_sprite_ext(sprMMDAPauseArrow, i, x + 32 + 7, y + 16*8.5, -1, 1, 0, col[i], 1);
                draw_sprite_ext(sprMMDAPauseArrow, i, x - 32 - 7 + 16*16, y + 16*8.5, 1, 1, 0, col[i], 1);
            }
        }
    }
    else{
        //draw items
        draw_set_color(c_white);
        draw_set_halign(fa_center);
        draw_text(x + 16*8, y + 16*5 - 8, "ITEMS");
        draw_set_halign(fa_left);
        
        draw_text(x + 32, y + 16*6, "MANUAL");
        
        //unselected tanks
        for (var i = 0; i &lt; 3; i++){
            draw_sprite(sprMenuTank, i, x + 32 + 16*i, y + 16*6.5);
        }
        draw_text(x + 32, y + 16*7.75, zeroPad(global.eTanks, 2));  
        draw_text(x + 48, y + 16*7.75, zeroPad(global.wTanks, 2));  
        draw_text(x + 64, y + 16*7.75, zeroPad(global.mTanks, 2));  
        //selected tanks
        for (var i = 0; i &lt; 3; i++){
            if (itemRow == 1 &amp;&amp; itemOption == 1 &amp;&amp; pauseRow == 0){ //etank
                if (i == 0){
                    draw_sprite_ext(sprETank, i*2, x + 32, y + 16*6.5, 1, 1, 0, c_white, 1);
                }
                else{
                    draw_sprite_ext(sprETank, i*2, x + 32, y + 16*6.5, 1, 1, 0, col[i], 1);
                }
            }
            if (itemRow == 1 &amp;&amp; itemOption == 2 &amp;&amp; pauseRow == 0){ //wtank
                if (i == 0){
                    draw_sprite_ext(sprWTank, i*2, x + 48, y + 16*6.5, 1, 1, 0, c_white, 1);
                }
                else{
                    draw_sprite_ext(sprWTank, i*2, x + 48, y + 16*6.5, 1, 1, 0, col[i], 1);
                }
            }
            if (itemRow == 1 &amp;&amp; itemOption == 3 &amp;&amp; pauseRow == 0){ //m-tank
                if (i == 0){
                    draw_sprite_ext(sprMTank, i*2, x + 64, y + 16*6.5, 1, 1, 0, c_white, 1);
                }
                else{
                    draw_sprite_ext(sprMTank, i*2, x + 64, y + 16*6.5, 1, 1, 0, col[i], 1);
                }
            }
        }
    }
    
    with(objMegaman){
        if (playerID == other.playerID){
            drawPlayer(playerID, costumeID, 17, 12, other.x + 16*4, other.y + 16*2.5 - 4, 1, 1); //mugshot
            drawPlayer(playerID, costumeID, 16, 12, other.x + 16*7 - 2, other.y + 16*2 - 8, 1, 1);
            drawPlayer(playerID, costumeID, 0, 0, other.x + 16*13 - 4, other.y + 16*3 - 8, 1, 1);
        }
    }
    
    draw_sprite_ext(sprBoltBig, 0, x + 16*7 - 4 + 32, y + 16*1.5 - 2, 1, 1, 0, c_white, 1);
    draw_sprite_ext(sprBoltBig, 1, x + 16*7 - 4 + 32, y + 16*1.5 - 2, 1, 1, 0, colP, 1);
    draw_sprite_ext(sprBoltBig, 2, x + 16*7 - 4 + 32, y + 16*1.5 - 2, 1, 1, 0, colS, 1);
    
    draw_set_valign(fa_middle);
    draw_text(x + 16*7 - 12 + 32, y + 16*3 - 2, zeroPad(global.bolts, 4));
    
    var livesText = zeroPad(global.livesRemaining, 2);
    if (!global.livesEnabled)
    {
        livesText = "--";
    }
    draw_text(x + 16*7 - 8, y + 16*3 - 2, livesText);
    
    draw_set_valign(fa_left);
    
    if pauseRow == 1 &amp;&amp; pauseRowOption == 0 //weapon option selected
    {
        for (var i = 0; i &lt; 3; i++){
            draw_sprite_ext(sprMMDAPauseWeapon, i, x + 30, y + 179 + 21, 1, 1, 0, col[i + 1], 1);
        }
    }
    else
    {
        //draw_sprite(sprPauseOptions, 5, x + 30, y + 179 + 21)
        for (var i = 0; i &lt; 3; i++){
            if (i == 0){
                draw_sprite_ext(sprMMDAPauseWeapon, i, x + 30, y + 179 + 21, 1, 1, 0, c_white, 1);
            }
            else{
                draw_sprite_ext(sprMMDAPauseWeapon, i, x + 30, y + 179 + 21, 1, 1, 0, col[i], 1);
            }
        }
    }
    
    
    if pauseRow == 1 &amp;&amp; pauseRowOption == 1
    {
        for (var i = 0; i &lt; 3; i++){
            draw_sprite_ext(sprMMDAPauseItem, i, x + 75, y + 179 + 21, 1, 1, 0, col[i + 1], 1);
        }
    }
    else
    {
        for (var i = 0; i &lt; 3; i++){
            if (i == 0){
                draw_sprite_ext(sprMMDAPauseItem, i, x + 75, y + 179 + 21, 1, 1, 0, c_white, 1);
            }
            else{
                draw_sprite_ext(sprMMDAPauseItem, i, x + 75, y + 179 + 21, 1, 1, 0, col[i], 1);
            }
        }
    }
    
    
    if pauseRow == 1 &amp;&amp; pauseRowOption == 2
    {
        for (var i = 0; i &lt; 3; i++){
            draw_sprite_ext(sprMMDAPauseSettings, i, x + 120, y + 179 + 21, 1, 1, 0, col[i + 1], 1);
        }
    }
    else
    {
        for (var i = 0; i &lt; 3; i++){
            if (i == 0){
                draw_sprite_ext(sprMMDAPauseSettings, i, x + 120, y + 179 + 21, 1, 1, 0, c_white, 1);
            }
            else{
                draw_sprite_ext(sprMMDAPauseSettings, i, x + 120, y + 179 + 21, 1, 1, 0, col[i], 1);
            }
        }
    }
    
    
    if pauseRow == 1 &amp;&amp; pauseRowOption == 3
    {
        if retryConfirm
        {
            for (var i = 0; i &lt; 3; i++){
                draw_sprite_ext(sprMMDAPauseRetry, i, x + 165, y + 179 + 21, 1, 1, 0, col[i + 1], 1);
            }
            draw_text(x + 165 - 24, y + 179 + 21 + 4, "OK?");
        }
        else
        {
            for (var i = 0; i &lt; 3; i++){
                draw_sprite_ext(sprMMDAPauseRetry, i, x + 165, y + 179 + 21, 1, 1, 0, col[i + 1], 1);
            }
        }
    }
    else
    {
        for (var i = 0; i &lt; 3; i++){
            if (i == 0){
                draw_sprite_ext(sprMMDAPauseRetry, i, x + 165, y + 179 + 21, 1, 1, 0, c_white, 1);
            }
            else{
                draw_sprite_ext(sprMMDAPauseRetry, i, x + 165, y + 179 + 21, 1, 1, 0, col[i], 1);
            }
        }
    }
    
    
    if pauseRow == 1 &amp;&amp; pauseRowOption == 4
    {
        if exitConfirm
        {
            for (var i = 0; i &lt; 3; i++){
                draw_sprite_ext(sprMMDAPauseExit, i, x + 210, y + 179 + 21, 1, 1, 0, col[i + 1], 1);
            }
            draw_text(x + 210 - 24, y + 179 + 21 + 4, "OK?");
        }
        else
        {
            for (var i = 0; i &lt; 3; i++){
                draw_sprite_ext(sprMMDAPauseExit, i, x + 210, y + 179 + 21, 1, 1, 0, col[i + 1], 1);
            }
        }
    }
    else
    {
        for (var i = 0; i &lt; 3; i++){
            if (i == 0){
                draw_sprite_ext(sprMMDAPauseExit, i, x + 210, y + 179 + 21, 1, 1, 0, c_white, 1);
            }
            else{
                draw_sprite_ext(sprMMDAPauseExit, i, x + 210, y + 179 + 21, 1, 1, 0, col[i], 1);
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
