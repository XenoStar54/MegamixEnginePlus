<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprFireSnakeyPreview</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtBoss</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* some values were changed from the original game to make the boss work better
without the original game's lag. The original values were left here as comments. */

event_inherited();

healthpointsStart = 28;
healthpoints = healthpointsStart;
contactDamage = 6;
xScaleStart = image_xscale;

//@cc
fireballContactDamage = 4;//6;

//@cc
flamethrowerContactDamage = 3;

grav = 0;
blockCollision = false;
bubbleTimer = -1;
dieToPits = false;

respawnRange = -1;
despawnRange = -1;

customPose = true;
introType = 0;
players = ds_list_create();

// creation code

//@cc where the player stops and turns to see the platform falling. Set to -1 to just go directly to the final cutscene position instead.
cutsceneWalkPauseX = bbox_right + 6 * 16;
if (image_xscale &lt; 0)
{
    cutsceneWalkPauseX = bbox_left - 6 * 16;
}

//@cc where the player stops to start the fight. Set to -1 to skip the intro sequence.
cutsceneWalkEndX = bbox_right + 3.5 * 16;
if (image_xscale &lt; 0)
{
    cutsceneWalkEndX = bbox_left - 3.5 * 16;
}

//@cc how far over fire snakey will appear when facing the other direction
flipDistance = 9 * 16;

//@cc how many body segments fire snakey has
bodySegmentCount = 10;

//@cc how far apart the body segments are
bodySegmentDistance = 15;

//@cc how delayed the segments are when jumping with the fire snakey
bodySegmentDelay = 3;

// that's at least a 5 on the wiggle meter
//@cc how wide of an area does fire snakey's body take up
wiggleWidth = 15;

//@cc how much y distance will make fire snakey's body parts do a full loop
wiggleHeight = 56;

//@cc offsets the position of the wiggle pattern
wiggleOffset = 0;

//@cc how high fire snakey rises when attacking
riseHeight = y;

//@cc the position in the screen that the boss hides in
submergeHeight = bbox_bottom - 24;

//@cc how fast fire snakey rises
riseSpd = -1.5;

//@cc how high fire snakey jumps
jumpHeight = y - 32;

//@cc x offset of where fire snakey shoots
shootX = 6;

//@cc y offset of where fire snakey shoots
shootY = 8;

//@cc how fast fireballs travel
fireballSpd = 4;//6;

//@cc time between fireballs
fireballWait = 48;//32;

//@cc how many fireballs are shot
fireballCount = 8;

//@cc how far the flamethrower goes
flamethrowerDistance = 5.5 * 16;

//@cc how fast the flamethrower goes (does not effect distance)
flamethrowerSpd = 4;

// @cc how long between each flamethrower ball
flamethrowerWait = 4;

// @cc how long the flame thrower is shot
flamethrowerTime = 4 * 63;

// variables
bodySegments = ds_list_create();
phase = 0;
subPhase = 0;
timer = 0;
counter = 0;
centerX = x;
fireballY = 0;

imgIndex = 0;
imgSpd = 1/6;

// healthbar
healthBarPrimaryColor[1] = 20;
healthBarSecondaryColor[1] = 40;

// Music
music = "WilyTowerBossTheme.vgm";
musicType = "VGM";
musicTrackNumber = 0;
musicVolume = 1;
musicLoopSecondsStart = 0;
musicLoopSecondsEnd = 0;

// Damage Tables
category = "fire";
enemyDamageValue(objBusterShot, 1);//2);
enemyDamageValue(objBusterShotHalfCharged, 2);//2);
enemyDamageValue(objBusterShotCharged, 2);//3);

// mm1
enemyDamageValue(objRollingCutter, 1);
enemyDamageValue(objSuperArmBlockProjectile, 1);
enemyDamageValue(objSuperArmDebris, 1);
enemyDamageValue(objIceSlasher, 2);
enemyDamageValue(objHyperBomb, 0);
enemyDamageValue(objFireStorm, 0);
enemyDamageValue(objThunderBeam, 1);
enemyDamageValue(objOilSlider, 0);

// mm2
enemyDamageValue(objMetalBlade, 1);
enemyDamageValue(objAirShooter, 1);
enemyDamageValue(objBubbleLead, 4);
enemyDamageValue(objQuickBoomerang, 2);
enemyDamageValue(objCrashBomberWeapon, 1);
stopOnFlash = false;
enemyDamageValue(objAtomicFire, 0);
enemyDamageValue(objLeafShield, 0);

// mm3
enemyDamageValue(objGeminiLaser, 1);
enemyDamageValue(objHardKnuckle, 2);
enemyDamageValue(objMagnetMissile, 1);
enemyDamageValue(objNeedleCannon, 1);
enemyDamageValue(objSearchSnake, 1);
enemyDamageValue(objShadowBlade, 1);
enemyDamageValue(objSparkShock, 1);
enemyDamageValue(objTopSpin, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// destroy lists
if (ds_exists(players, ds_type_list))
{
    ds_list_destroy(players);
}

if (ds_exists(bodySegments, ds_type_list))
{
    event_user(0); // destroy body segments
    
    ds_list_destroy(bodySegments);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (entityCanStep())
{
    if (startIntro)
    {
        image_xscale = xScaleStart;
        
        // setup parts
        sprite_index = sprFireSnakeyHeadStill;
        
        
        // start intro stuff
        canFillHealthBar = false;
        image_index = 0;
        startIntro = false;
        isIntro = true;
        visible = false;
        
        // create player cutscene controllers
        introLock = lockPoolRelease(introLock);
        
        with (objMegaman)
        {
            var cont = instance_create(x, y, objPlayerCutsceneController);
            cont.playerObj = id;
            ds_list_add(other.players, cont);
        }
    }
    else if (isIntro)
    {
        // release intro locks or else the cutscene controller can't move the players
        with (prtBoss)
        {
            if (isLocked(introLock))
            {
                introLock = lockPoolRelease(introLock);
            }
        }
        
        // delete null cutscene controllers
        for (var i = 0; i &lt; ds_list_size(players); i++)
        {
            if (!instance_exists(ds_list_find_value(players, i)))
            {
                ds_list_delete(players, i);
                i--; // list entries shift over
            }
        }
        
        // behavior
        switch (phase)
        {
            // go to end of springboard after landing
            case 0:
                // skip parts of the intro
                if (cutsceneWalkEndX &lt;= 0)
                {
                    // skip entire intro sequence
                    phase = 2;
                    break;
                }
                else if (cutsceneWalkPauseX &lt;= 0 &amp;&amp; cutsceneWalkEndX &gt; 0)
                {
                    // skip walk pause and go to final walk position
                    for (var i = 0; i &lt; ds_list_size(players); i++)
                    {
                        var p = ds_list_find_value(players, i);
                        p.xTarget = cutsceneWalkEndX;
                    }
                    
                    phase = 2;
                    break;
                }
                
                with (objMMWTFallingPlatform)
                {
                    timer = 0;
                    dropTime = 999999; // only drop when cutscene is ready
                }
                
                var allDone = true;
                for (var i = 0; i &lt; ds_list_size(players); i++)
                {
                    var p = ds_list_find_value(players, i);
                    
                    // initiate walk
                    if (p.xTarget == 0 &amp;&amp; p.playerObj.x != cutsceneWalkPauseX
                        &amp;&amp; p.playerObj.ground)
                    {
                        p.xTarget = cutsceneWalkPauseX;
                    }
                    
                    // done with walk
                    if (p.playerObj.x != cutsceneWalkPauseX || p.busy)
                    {
                        allDone = false;
                    }
                }
                
                if (allDone)
                {
                    // safely drop platform
                    with (objMMWTFallingPlatform)
                    {
                        dropTime = 0;
                    }
                    
                    phase++;
                }
                
                break;
            
            // brief wait before walking to center of the stage
            case 1:
                timer++;
                
                // face the falling platform
                if (timer == 15)
                {
                    for (var i = 0; i &lt; ds_list_size(players); i++)
                    {
                        var p = ds_list_find_value(players, i);
                        p.playerObj.image_xscale = -p.playerObj.image_xscale;
                    }
                }
                
                // wait
                if (timer &gt;= 90)
                {
                    timer = 0;
                    
                    for (var i = 0; i &lt; ds_list_size(players); i++)
                    {
                        var p = ds_list_find_value(players, i);
                        p.xTarget = cutsceneWalkEndX;
                    }
                    
                    phase++;
                }
                
                break;
            
            // walk to center
            case 2:
                var areBusy = false;
                for (var i = 0; i &lt; ds_list_size(players); i++)
                {
                    var p = ds_list_find_value(players, i);
                    if (p.busy)
                    {
                        areBusy = true;
                        break;
                    }
                }
                
                // start fight
                if (!areBusy)
                {
                    // end intro
                    phase = -1;
                    
                    isIntro = false;
                    canFillHealthBar = true;
                }
                
                break;
        }
    }
    else if (isFight)
    {
        var offsetCorrect = 6;
        
        switch (phase)
        {
            // initialize after healthbar fills
            case -1:
                y = submergeHeight + sprite_get_yoffset(sprite_index); // hide below submerge height
                visible = true;
                
                // destroy player controllers
                for (var i = ds_list_size(players) - 1; i &gt;= 0; i--)
                {
                    instance_destroy(ds_list_find_value(players, i));
                    ds_list_delete(players, i);
                }
                
                ds_list_destroy(players);
                
                // body parts
                for (var i = 0; i &lt; bodySegmentCount; i++)
                {
                    var b = instance_create(x, y, objFireSnakeySegment);
                    b.parent = id;
                    b.distance = (i + 1) * bodySegmentDistance;
                    b.followDelay = (i + 1) * bodySegmentDelay;
                    b.depth = depth + 1 + i;
                    b.stopOnFlash = stopOnFlash;
                    ds_list_add(bodySegments, b);
                }
                
                phase++;
                break;
            
            // rise up and shoot fireballs / flamethrower
            case 0:
                switch (subPhase)
                {
                    // prepare
                    case 0:
                        // choose position
                        image_xscale = choose(1, -1);
                        centerX = xstart + offsetCorrect * -image_xscale
                        if (image_xscale != xScaleStart)
                        {
                            centerX += flipDistance * -image_xscale;
                        }
                        
                        // set all segments to wiggle
                        for (var i = 0; i &lt; ds_list_size(bodySegments); i++)
                        {
                            var b = ds_list_find_value(bodySegments, i);
                            if (instance_exists(b))
                            {
                                b.follow = false;
                            }
                        }
                        
                        subPhase++;
                        break;
                        
                    // rise up (gamers)
                    case 1:
                        yspeed = riseSpd;
                        
                        if (y &lt;= riseHeight)
                        {
                            y = riseHeight; 
                            yspeed = 0;
                            subPhase++;
                        }
                        
                        break;
                    
                    // pause before doing an action
                    case 2:
                        timer++;
                        if (timer &gt;= 73)
                        {
                            timer = 0;
                            subPhase = choose(3, 4); // randomly choose between fireballs and flamethrower
                        }
                        
                        break;
                    
                    // FIYA BALLS
                    case 3:
                        timer--;
                        if (timer &lt;= 0)
                        {
                            timer = fireballWait;
                            
                            var f = instance_create(x + shootX * image_xscale, y + shootY, objEnemyBullet);
                            f.sprite_index = sprFireSnakeyFireball;
                            f.image_speed = (1/8) * 2; // * 2 because the original game's animation speed looks too slow
                            f.image_xscale = image_xscale;
                            f.contactDamage = fireballContactDamage;
                            f.stopOnFlash = stopOnFlash;
                            f.reflectable = true;
                            
                            var a = -45 - 90 * (image_xscale == -1);
                            if (instance_exists(target))
                            {
                                if (sign(target.x - f.x) == image_xscale) // aim only if they're in front of us
                                {
                                    var a = point_direction(f.x, f.y, target.x, target.y);
                                }
                            }
                            
                            f.xspeed = fireballSpd * cos(degtorad(a));
                            f.yspeed = fireballSpd * -sin(degtorad(a));
                            
                            playSFX(sfxSolarBlazeLarge);
                            
                            counter++;
                            if (counter &gt;= 8)
                            {
                                timer = 0;
                                counter = 0;
                                subPhase = 5;
                                imgIndex -= 2;
                            }
                        }
                        
                        break;
                    
                    // flamethrower
                    case 4:
                        if (timer == 0)
                        {
                            playSFX(sfxPopoHeliFire);
                        }
                        
                        timer++;
                        if (timer mod 4 == 0)
                        {
                            var f = instance_create(x + shootX * image_xscale, y + shootY, objEnemyBullet);
                            f.sprite_index = sprFireSnakeyFlamethrower;
                            f.image_speed = (1 / (flamethrowerDistance / flamethrowerSpd)) * sprite_get_number(f.sprite_index);
                            f.image_index = 0;
                            f.contactDamage = flamethrowerContactDamage;
                            f.alarmDie = (flamethrowerDistance / flamethrowerSpd);
                            f.stopOnFlash = stopOnFlash;
                            f.reflectable = false;
                            
                            var a = -45 - 90 * (image_xscale == -1);
                            if (instance_exists(target))
                            {
                                if (sign(target.x - f.x) == image_xscale) // aim only if they're in front of us
                                {
                                    var a = point_direction(f.x, f.y, target.x, target.y);
                                }
                            }
                            
                            f.xspeed = flamethrowerSpd * cos(degtorad(a));
                            f.yspeed = flamethrowerSpd * -sin(degtorad(a));
                        }
                        
                        if (timer &gt;= flamethrowerTime)
                        {
                            timer = 0;
                            subPhase = 5;
                            imgIndex -= 2;
                        }
                        
                        break;
                    
                    // lower down (gamers)
                    case 5:
                        yspeed = -riseSpd;
                        if (y &gt;= submergeHeight + sprite_get_yoffset(sprite_index))
                        {
                            y = submergeHeight + sprite_get_yoffset(sprite_index);
                            yspeed = 0;
                            subPhase = 0;
                            
                            phase = 1; // do jump next
                        }
                        
                        break;
                }
                
                // Wiggling. "y - riseHeight" is to align the wiggling so the head is the greatest distance away from the center at the riseHeight
                x = centerX + (wiggleWidth / 2) * cos(degtorad(((y - riseHeight) / wiggleHeight) * 360 + wiggleOffset + 180 * (image_xscale == -1))); 
                
                // animation
                imgIndex += imgSpd;
                if (subPhase &lt; 5)
                {
                    // open mouth
                    if (imgIndex &gt;= 4)
                    {
                        imgIndex = 2;
                    }
                }
                else
                {
                    // closed mouth
                    if (imgIndex &gt;= 2)
                    {
                        imgIndex = 0;
                    }
                }
                
                break;
            
            // jump
            case 1:
                // sfxSolarBlazeSmall
                switch (subPhase)
                {
                    // wait before jump
                    case 0:
                        timer++;
                        if (timer &gt;= 122)
                        {
                            timer = 0;
                            
                            // set position
                            image_xscale = choose(1, -1);
                            centerX = xstart + offsetCorrect * -image_xscale
                            if (image_xscale != xScaleStart)
                            {
                                centerX += flipDistance * -image_xscale;
                            }
                            
                            image_xscale = choose(1, -1);
                            x = xstart + offsetCorrect * -image_xscale;
                            var xt;
                            if (image_xscale != xScaleStart)
                            {
                                x += flipDistance * -image_xscale;
                                xt = xstart + offsetCorrect * image_xscale;
                            }
                            else
                            {
                                xt = xstart + offsetCorrect * image_xscale + flipDistance * image_xscale;
                            }
                            
                            y = submergeHeight + sprite_get_yoffset(sprite_index);
                            
                            // set jump
                            grav = gravAccel;
                            yspeed = ySpeedAim(y, jumpHeight);
                            xspeed = xSpeedAim(x, y, xt, y); 
                            
                            // set all segments to follow
                            for (var i = 0; i &lt; ds_list_size(bodySegments); i++)
                            {
                                var b = ds_list_find_value(bodySegments, i);
                                b.follow = true;
                                b.x = x;
                                b.y = y;
                                b.followXSpeed = xspeed;
                                b.followYSpeed = yspeed;
                                b.followGrav = grav;
                            }
                            
                            // sprite
                            sprite_index = sprFireSnakeyHeadTurn;
                            imgIndex = 0;
                            
                            subPhase++;
                        }
                        
                        break;
                    
                    // jumping
                    case 1:
                        // spawn fireballs when going under submerge height if there's no spikes (aka lava)
                        if (sign(yprevious - submergeHeight) != sign(y - submergeHeight)
                            &amp;&amp; !place_meeting(x, submergeHeight, objSpike) &amp;&amp; !place_meeting(x, submergeHeight, objDamageSpike))
                        {
                            fireballY = submergeHeight;
                            event_user(1); // spawn fireballs
                            show_debug_message("no spike fireballs");
                            playSFX(sfxSolarBlazePopLarge);
                        }
                        
                        // turn animation
                        var a = radtodeg(arctan(-yspeed / abs(xspeed))); // angle of movement
                        imgIndex = clamp(((45 + 45/2) - a) div 45, 0, 3);
                        
                        // finish
                        if (sign(yspeed) == sign(grav) &amp;&amp; y &gt;= submergeHeight + sprite_get_yoffset(sprite_index))
                        {
                            xspeed = 0;
                            yspeed = 0;
                            grav = 0;
                            y = submergeHeight + sprite_get_yoffset(sprite_index);
                            sprite_index = sprFireSnakeyHeadStill;
                            imgIndex = 0;
                            subPhase++;
                        }
                        
                        break;
                    
                    // wait until doing next action
                    case 2:
                        timer++;
                        if (timer &gt;= 74)
                        {
                            timer = 0;
                            subPhase = 0;
                            phase = 0; // rise up and attack next
                        }
                        
                        break;
                    
                }
                
                break;
        }
        
        // splash
        var c1 = collision_line(bbox_left, y, bbox_right, y, objSpike, false, false);
        var c2 = collision_line(bbox_left, yprevious, bbox_right, yprevious, objSpike, false, false);
        var proceed = instance_exists(c1) ^^ instance_exists(c2); // XOR OPERATOR FOR THE WIN
        if (instance_exists(c1) || instance_exists(c2))
        {
            show_debug_message("y: " + string(y));
            show_debug_message("yprevious: " + string(yprevious));
            show_debug_message("submergeHeight: " + string(submergeHeight));
            show_debug_message("c1: " + string(c1));
            show_debug_message("c2: " + string(c2));
        }
        
        if (!proceed)
        {
            // search for damage spikes instead
            c1 = collision_line(bbox_left, y, bbox_right, y, objDamageSpike, false, false);
            c2 = collision_line(bbox_left, yprevious, bbox_right, yprevious, objDamageSpike, false, false);
            proceed = instance_exists(c1) ^^ instance_exists(c2); // XOR OPERATOR FOR THE WIN
        }
        
        if ((y  &lt; submergeHeight || yprevious &lt; submergeHeight) &amp;&amp; proceed)
        {
            if (instance_exists(c2))
            {
                c1 = c2;
            }
            
            var s = instance_create(x - 8 * image_xscale * (phase == 0), c1.bbox_top, objSlideDust);
            s.sprite_index = sprFireSnakeySplash;
            s.image_yscale = sign((c1.bbox_bottom + c1.bbox_top) / 2 - y);
            s.imgSpd = 1/6;
            s.alarm[0] = (1/s.imgSpd) * s.image_number;
            
            if (phase == 0)
            {
                playSFX(sfxSolarBlazeSmall);
            }
            else
            {
                playSFX(sfxSolarBlazePopLarge);
                
                // spawn fireballs
                fireballY = c1.bbox_top;
                event_user(1); // spawn fireballs
                show_debug_message("spike fireballs");
            }
        }
    }
}

image_index = imgIndex div 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (spawned)
{
    phase = 0;
    subPhase = 0;
    timer = 0;
    counter = 0;
    imgIndex = 0;
    
    event_user(0); // delete body segments
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with (objEnemyBullet)
{
    instance_destroy();
}

event_user(0); // destroy body segments

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// spawn splash fireballs
for (var i = 0; i &lt; 3; i++)
{
    var f = instance_create(x, fireballY, objEnemyBullet);
    f.sprite_index = sprFireSnakeyFireball;
    f.image_speed = (1/8) * 2; // * 2 because the original game's animation speed looks too slow
    f.image_xscale = image_xscale;
    f.contactDamage = fireballContactDamage;
    f.grav = gravAccel;
    f.stopOnFlash = stopOnFlash;
    f.reflectable = true;
    
    switch (i)
    {
        case 0:
            f.xspeed = 0.78;
            f.yspeed = -6;
            break;
        case 1:
            f.xspeed = 1.28;
            f.yspeed = -7;
            break;
        
        case 2:
            f.xspeed = -1.28;
            f.yspeed = -6;
            break;
    }
    
    f.xspeed *= image_xscale;
    
    // randomness
    f.xspeed += random_range(-0.4, 0.4);
    f.yspeed += random_range(0.4, -0.3);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// delete body segments
if (ds_exists(bodySegments, ds_type_list))
{
    if (!ds_list_empty(bodySegments))
    {
        for (var i = ds_list_size(bodySegments) - 1; i &gt;= 0; i--)
        {
            var b = ds_list_find_value(bodySegments, i);
            if (instance_exists(b))
            {
                with (b)
                {
                    instance_destroy();
                }
            }
            
            ds_list_delete(bodySegments, i);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
