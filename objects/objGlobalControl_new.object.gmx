<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100000</depth>
  <persistent>-1</persistent>
  <parentName>prtAlwaysActive</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialization

//// global initialization ////

// set random seed
randomize();

// engine configuration options
engineConfig();

/// global variable setup
globalInit();

//// instance variables private to objGlobalControl ////

levelupTimer = 0;

// fade in/out
fadeAlpha = 0;
fadestep = 0.2;
fadeinterval = 3;
fadetimer = 0;

// health bar
showhealth = 0;
increaseHealth = false;
increaseAmmo = false;
increaseSubAmmo = false;
increaseTimer = 0;
increaseWeapon = 0;
increaseSubWeapon = 0;
depthstart = depth;
depthAlter = 0;

// save icon
saveTimer = -1;
saveFrame = 0;

// list of pickups (prevents pickup respawning)
pickups = ds_list_create();

// used for pausing
setfrozen = 0;

// pause list
obj[0] = prtEntity;
obj[1] = prtEffect;

/// User-specific globals ////

// new save file
freshSaveFile();

// default options
freshOptions();

// load user's options (if they exist)
saveLoadOptions(false);

/// set up display ///

setScreenSize(global.screensize);
display_reset(0, global.vsync);

//// Create other control objects ////
instance_create(0, 0, objMusicControl);
instance_create(0, 0, objDebugControl);
instance_create(0, 0, objMobileControl);

global.levelTimerRun = false;
global.levelTimerShow = false;
global.levelTimer = 99 * 60;
timerColor = 37;

//Used to load a room passed as parameter
init=1;

// show disclaimer
room_goto(rmDisclaimer);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// death -- restart
global.nextRoom = global.checkpoint;

// game over
if (global.livesRemaining &lt;= 0 &amp;&amp; global.livesEnabled &amp;&amp; global.inGame)
{
    // recordings should stop
    if (global.recordInputMode != 0)
    {
        global.recordInputDeath = true;
    }
    else
    {
        global.nextRoom = rmGameOver;
        //global.nextRoom = rmContinueTimer;//rmGameOver;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// camera update, flicker, and fade

if (!instance_exists(objSectionSwitcher) &amp;&amp; global.inGame)
{
    // Camera
    playerCamera(1);
    
    // screen shaking
    if (!global.frozen)
    {
        view_xview[0] += choose(-global.shakeFactorX, 0, global.shakeFactorX);
        view_yview[0] += choose(-global.shakeFactorY, 0, global.shakeFactorY);
    }
    
    with (prtCustomCamera)
    {
        event_user(0);
    }
}

// Flicker
depthAlter = !depthAlter;
if (depthAlter)
{
    depth = 10;
}

for (i = 0; i &lt;= 1; i += 1)
{
    with (obj[i])
    {
        if (depth &lt; 100000 &amp;&amp; !noFlicker)
        {
            depth = floor(depth) + (irandom(99) * 0.01);
        }
    }
}

if (global.nextRoom != 0 || fadeAlpha &gt; 0)
{
    fadetimer += (1);
    //fadetimer += (1 + instance_exists(objPauseMenu));
    
    if (fadetimer &gt;= fadeinterval)
    {
        if (global.nextRoom &amp;&amp; fadeAlpha == 1)
        {
            global.previousRoom = room;
            room_goto(global.nextRoom);
        }
        
        fadeAlpha += fadestep * (1 - (2 * (global.nextRoom == 0)));
        fadeAlpha = max(0, min(1, fadeAlpha));
        
        fadetimer = 0;
        if (fadeAlpha == 1)
        {
            fadetimer = -5;
        }
        else if (global.nextRoom == 0 &amp;&amp; fadeAlpha == 0)
        {
            if (!instance_exists(objPauseMenu))
            {
                global.frozen = false;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load room from parameter
if(init &amp;&amp; room == rmDisclaimer)
{
    init=0;
    if(parameter_count()&gt;1)
    {
        var filename = "+" + parameter_string(1);
        if(filename!="+" &amp;&amp; stringEndsWith(filename,".room.gmx"))
        {
        
            var nrm = roomExternalLoad(filename);
            goToLevel(nrm);
            exit;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// revert camera effects

if (!instance_exists(objSectionSwitcher) &amp;&amp; global.inGame)
{
    view_xview[0] = global.cachedXView;
    view_yview[0] = global.cachedYView;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// game timers

global.roomTimer += 1;
global.gameTimer += 1;
if global.levelTimerRun &amp;&amp; !global.frozen &amp;&amp; !global.timeStopped{

if global.arcadeMode{
    if global.levelTimer &gt; 0
        global.levelTimer -= 1;
    else
        global.playerHealth[0] = 0;
}
else
{
    global.levelTimer += 1;
}       
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// player input
// Inputs

// Gamepad info
xinputDeviceCount = 0;
for (var i = 0; i &lt; 4; i++)
{
    if (gamepad_is_connected(i))
        xinputDeviceCount++;
}

var n_connected = 0;
for (var i = 0; i &lt; gamepad_get_device_count(); i += 1)
{
    if (gamepad_is_connected(i))
        n_connected += 1;
}
n_connected = min(n_connected, global.playerCount);
for (i = 0; i &lt; global.playerCount; i += 1)
{
    // Input
    keyLeftHold = global.keyLeft[i];
    keyRightHold = global.keyRight[i];
    keyUpHold = global.keyUp[i];
    keyDownHold = global.keyDown[i];
    keyJumpHold = global.keyJump[i];
    keyShootHold = global.keyShoot[i];
    keyMapHold = global.keyMap[i];
    keyPowerGearHold = global.keyPowerGear[i];
    keySpeedGearHold = global.keySpeedGear[i];
    keyDoubleGearHold = global.keyDoubleGear[i];
    keyTurboHold = global.keyTurbo[i];
    keySubWeaponHold = global.keySubWeapon[i];
    keySlideHold = global.keySlide[i];
    keyPauseHold = global.keyPause[i];
    keyWeaponSwitchLeftHold = global.keyWeaponSwitchLeft[i];
    keyWeaponSwitchRightHold = global.keyWeaponSwitchRight[i];
    
    // Check keys
    global.keyLeft[i] = keyboard_check(global.leftKey[i]);
    global.keyRight[i] = keyboard_check(global.rightKey[i]);
    global.keyUp[i] = keyboard_check(global.upKey[i]);
    global.keyDown[i] = keyboard_check(global.downKey[i]);
    global.keyJump[i] = keyboard_check(global.jumpKey[i]);
    global.keyShoot[i] = keyboard_check(global.shootKey[i]);
    global.keyMap[i] = keyboard_check(global.mapKey[i]);
    global.keyPowerGear[i] = keyboard_check(global.powerGearKey[i]);
    global.keySpeedGear[i] = keyboard_check(global.speedGearKey[i]);
    global.keyDoubleGear[i] = keyboard_check(global.doubleGearKey[i]);
    global.keyTurbo[i] = keyboard_check(global.turboKey[i]);
    global.keySubWeapon[i] = keyboard_check(global.subWeaponKey[i]);
    global.keySlide[i] = keyboard_check(global.slideKey[i]);
    global.keyPause[i] = keyboard_check(global.pauseKey[i])
        || (keyboard_check_pressed(vk_escape)
        &amp;&amp; global.escapeBehavior == 1);
    global.keyWeaponSwitchLeft[i] = keyboard_check(
        global.weaponSwitchLeftKey[i]);
    global.keyWeaponSwitchRight[i] = keyboard_check(
        global.weaponSwitchRightKey[i]);
    
    jp = i;
    
    if (n_connected &gt; 0)
    {
        if (!gamepad_is_connected(jp))
        {
            jp += 4 - xinputDeviceCount;
        }
        if (gamepad_is_connected(jp))
        {
            if (gamepad_axis_count(jp) &gt;= 2)
            {
                // Check D-Pad first
                
                var dPad = false;
                if (joystick_has_pov(jp))
                {
                    var angle = joystick_pov(jp);
                    if (angle != -1)
                        dPad = true;
                    switch (angle)
                    {
                        case 0:
                            global.keyUp[i] += 1;
                            break;
                        case 45:
                            global.keyRight[i] += 1;
                            global.keyUp[i] += 1;
                            break;
                        case 90:
                            global.keyRight[i] += 1;
                            break;
                        case 135:
                            global.keyDown[i] += 1;
                            global.keyRight[i] += 1;
                            break;
                        case 180:
                            global.keyDown[i] += 1;
                            break;
                        case 225:
                            global.keyLeft[i] += 1;
                            global.keyDown[i] += 1;
                            break;
                        case 270:
                            global.keyLeft[i] += 1;
                            break;
                        case 315:
                            global.keyLeft[i] += 1;
                            global.keyUp[i] += 1;
                            break;
                    }
                }
                
                // Analog Stick position
                if (!dPad)
                {
                    var axX = gamepad_axis_value(jp, gp_axislh);
                    var axY = gamepad_axis_value(jp, gp_axislv);
                    if ((abs(axY) &gt; 0.4) || (abs(axX) &gt; 0.36))
                    {
                        gamepadStick = point_direction(0, 0, axX, axY);
                        global.keyLeft[i] += (gamepadStick &gt;= 120
                            &amp;&amp; gamepadStick &lt;= 240);
                        global.keyRight[i] += ((gamepadStick &lt;= 60)
                            || gamepadStick &gt;= 300);
                        global.keyUp[i] += (gamepadStick &gt;= 30
                            &amp;&amp; gamepadStick &lt;= 150);
                        global.keyDown[i] += (gamepadStick &gt;= 210
                            &amp;&amp; gamepadStick &lt;= 330);
                    }
                }
            }
            global.keyJump[i] += gamepad_button_check(jp,
                global.joystick_jumpKey[i]);
            global.keyShoot[i] += gamepad_button_check(jp,
                global.joystick_shootKey[i]);
            global.keySlide[i] += gamepad_button_check(jp,
                global.joystick_slideKey[i]);
            global.keyPause[i] += gamepad_button_check(jp,
                global.joystick_pauseKey[i]);
            global.keyWeaponSwitchLeft[i] += gamepad_button_check(jp,
                global.joystick_weaponSwitchLeftKey[i]);
            global.keyWeaponSwitchRight[i] += gamepad_button_check(jp,
                global.joystick_weaponSwitchRightKey[i]);
        }
    }
    
    // Key pressed stuff
    global.keyLeftPressed[i] = global.keyLeft[i] &amp;&amp; !keyLeftHold;
    global.keyRightPressed[i] = global.keyRight[i] &amp;&amp; !keyRightHold;
    global.keyUpPressed[i] = global.keyUp[i] &amp;&amp; !keyUpHold;
    global.keyDownPressed[i] = global.keyDown[i] &amp;&amp; !keyDownHold;
    global.keyJumpPressed[i] = global.keyJump[i] &amp;&amp; !keyJumpHold;
    
    global.keyShootPressed[i] = global.keyShoot[i] &amp;&amp; !keyShootHold;
    
    global.keyPowerGearPressed[i] = global.keyPowerGear[i] &amp;&amp; !keyPowerGearHold;
    global.keySpeedGearPressed[i] = global.keySpeedGear[i] &amp;&amp; !keySpeedGearHold;
    global.keyDoubleGearPressed[i] = global.keyDoubleGear[i] &amp;&amp; !keyDoubleGearHold;
    
    global.keyMapPressed[i] = global.keyMap[i] &amp;&amp; !keyMapHold;
    global.keyTurboPressed[i] = global.keyTurbo[i] &amp;&amp; !keyTurboHold;
    global.keySubWeaponPressed[i] = global.keySubWeapon[i] &amp;&amp; !keySubWeaponHold;
    global.keySlidePressed[i] = global.keySlide[i] &amp;&amp; !keySlideHold;
    global.keyPausePressed[i] = global.keyPause[i] &amp;&amp; !keyPauseHold;
    global.keyWeaponSwitchLeftPressed[i] = global.keyWeaponSwitchLeft[i]
        &amp;&amp; !keyWeaponSwitchLeftHold;
    global.keyWeaponSwitchRightPressed[i] = global.keyWeaponSwitchRight[i]
        &amp;&amp; !keyWeaponSwitchRightHold;
}

// recorded controls dubbing:
recordInputHandle();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// freeze / unfreeze game objects
if (global.frozen)
{
    var len = array_length_1d(obj);
    for (i = 0; i &lt; len; i += 1)
    {
        with (obj[i])
        {
            if (!frozen) // Start Freeze
            {
                pre_hsp = hspeed;
                pre_vsp = vspeed;
                pre_spe = speed;
                pre_isp = image_speed;
                hspeed = 0;
                vspeed = 0;
                speed = 0;
                image_speed = 0;
                frozen = 1;
            }
            
            for (_i = 0; _i &lt;= 11; _i += 1)
            {
                if (alarm[_i] &gt; 0)
                {
                    alarm[_i] += 1;
                }
            }
        }
    }
    setfrozen = 1;
}
else if (setfrozen) // Stop Freeze
{
    var len = array_length_1d(obj);
    for (i = 0; i &lt; len; i += 1)
    {
        with (obj[i])
        {
            if (frozen)
            {
                hspeed = pre_hsp;
                vspeed = pre_vsp;
                speed = pre_spe;
                image_speed = pre_isp;
                frozen = 0;
            }
        }
    }
    setfrozen = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Respawn players
if (global.frozen)
{
    exit;
}

global.respawnAllowed = false;

with (objMegaman)
{
    if (gravDir &gt; 0)
    {
        global.respawnAllowed = true;
    }
}

with (objMegaman)
{
    if (global.playerHealth[playerID] &gt; global.respawnDonateThreshold)
    {
        global.respawnAllowed = true;
    }
    if (playerIsLocked(PL_LOCK_PAUSE))
    {
        global.respawnAllowed = false;
    }
}

if (instance_exists(objAutoScroller))
{
    global.respawnAllowed = false;
}

for (i = 0; i &lt; global.playerCount; i += 1)
{
    if (global.respawnTimer[i] &gt;= 0)
    {
        if (global.respawnTimer[i])
        {
            global.respawnTimer[i] -= 1;
            if (!instance_exists(objMegaman))
            {
                global.respawnTimer[i] = -1;
            }
        }
        
        if (!instance_exists(prtBoss)
            &amp;&amp; global.respawnTimer[i] &gt; global.respawnTime)
        {
            global.respawnTimer[i] = global.respawnTime;
        }
        
        if (global.keyPausePressed[i] &amp;&amp; global.respawnAllowed
            &amp;&amp; !global.respawnTimer[i])
        {
            // Check no existing player already has this id
            var nogo = false;
            with (objMegaman)
            {
                if (playerID == i)
                {
                    nogo = true;
                }
            }
            if (nogo)
            {
                continue;
            }
            
            if (!global.respawnAllowed)
            {
                playSFX(sfxError);
                continue;
            }
            playSFX(sfxMenuSelect);
            
            // determine respawn health:
            var donators = 1;
            var respawn_health = 0;
            
            with (objMegaman)
            {
                if (global.playerHealth[playerID]
                    &gt; global.respawnDonateThreshold)
                {
                    donators += 1;
                }
            }
            with (objMegaman)
            {
                donate = floor(global.playerHealth[playerID] / donators)
                    * (global.playerHealth[playerID]
                    &gt; global.respawnDonateThreshold);
                if donate &gt; 0
                {
                    respawn_health += donate;
                    global.playerHealth[playerID] -= donate;
                }
                else
                {
                    playSFX(sfxError);
                    exit;
                }
            }
            
            // respawn player at random other player's coords
            targetPlayer = instance_find(objMegaman,
                irandom(instance_number(objMegaman) - 1));
            prev_checkpoint = global.checkpoint;
            global.checkpoint = -1;
            
            p = instance_create(targetPlayer.x, targetPlayer.y, objMegaman);
            p.gravfactor = targetPlayer.gravfactor;
            p.inWater = targetPlayer.inWater;
            p.inRoboenzaWater = targetPlayer.inRoboenzaWater;
            p.grav = targetPlayer.grav;
            p.gravWater = targetPlayer.gravWater;
            with (p)
            {
                // teleporting init
                teleportLock = lockPoolLock(
                    localPlayerLock[PL_LOCK_MOVE],
                    localPlayerLock[PL_LOCK_PHYSICS],
                    localPlayerLock[PL_LOCK_SHOOT],
                    localPlayerLock[PL_LOCK_CLIMB],
                    localPlayerLock[PL_LOCK_CHARGE],
                    localPlayerLock[PL_LOCK_GEAR],
                    localPlayerLock[PL_LOCK_PAUSE],
                    localPlayerLock[PL_LOCK_TURN],
                    localPlayerLock[PL_LOCK_GRAVITY]);
                canHit = false;
            }
            
            global.checkpoint = prev_checkpoint;
            p.playerID = i;
            global.playerHealth[i] = respawn_health;
            global.respawnTimer[i] = -1;
            objGlobalControl.alarm[0] = -1;
            global.decrementLivesOnRoomEnd = false;
            with (p)
            {
            teleportLock = lockPoolRelease(teleportLock);
            canHit = true;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Level Up?
levelupTimer = max (0, levelupTimer - 1)
if (global.playerExp &gt;= global.playerExpMax &amp;&amp; instance_exists(objMegaman))
{
    
    global.playerExp = 0;
    global.playerLVL++
    playSFX(sfxLevelUp);
    global.damage = 0;
    /*with (objMegaman)
    {
    i = instance_create(x, y, objDamagePopup);
    i.str = "LEVEL UP!";
    i.image_blend = c_purple;
    }*/
    /*with (objGlobalControl)
    {
        levelupTimer = 150;
    }*/
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///EnemyDisp Time
if (global.enemyTime &gt; 0)
{
    global.enemyTime--
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// energy handling and screen shake

x = view_xview[0] + 16;
y = view_yview[0] + 16;

// Infinite energy handling
for (i = 0; i &lt;= global.totalWeapons; i += 1)
{
    if (global.infiniteEnergy[i])
    {
        for (j = 0; j &lt; global.playerCount; j += 1)
        {
            global.ammo[j, i] = 28;
        }
    }
}

if (increaseHealth || increaseAmmo) // Increase Health and/or Ammo
{
    if (global.healthEffect) // Instant
    {
        if (increaseHealth)
        {
            global.playerHealth[increasePID] = ceil(global.playerHealth[increasePID] + increaseHealth);
            playSFX(sfxEnergyRestore);
            
            increaseHealth = 0;
        }
        if (increaseAmmo)
        {
            global.ammo[increasePID, increaseWeapon] = ceil(global.ammo[increasePID, increaseWeapon] + increaseAmmo);
            playSFX(sfxEnergyRestore);
            
            increaseAmmo = 0;
        }
        if (increaseSubAmmo)
        {
            global.subWeaponAmmo[increasePID, increaseSubWeapon] = ceil(global.subWeaponAmmo[increasePID, increaseSubWeapon] + increaseSubAmmo);
            playSFX(sfxEnergyRestore);
            
            increaseSubAmmo = 0;
        }
    }
    else
    {
        increaseTimer += 1;
        
        if (!(increaseTimer mod 3))
        {
            increaseHealth *= (global.playerHealth[increasePID] &lt; 28);
            if (increaseHealth)
            {
                global.playerHealth[increasePID] = floor(global.playerHealth[increasePID]) + 1;
                increaseHealth = max(increaseHealth - 1, 0);
            }
            increaseAmmo *= (global.ammo[increasePID, increaseWeapon] &lt; 28);
            if (increaseAmmo)
            {
                global.ammo[increasePID, increaseWeapon] = floor(global.ammo[increasePID, increaseWeapon]) + 1;
                increaseAmmo = max(increaseAmmo - 1, 0);
            }
        }
    }
    
    if (!increaseHealth &amp;&amp; !increaseAmmo)
    {
        global.frozen = false;
        increaseTimer = 0;
        if (!global.healthEffect)
        {
            audio_stop_sound(sfxEnergyRestore);
        }
    }
    
    // make sure ammo never goes past 28
    if (global.playerHealth[increasePID] &gt; 28)
    {
        global.playerHealth[increasePID] = 28;
    }
    
    if (global.ammo[increasePID, increaseWeapon] &gt; 28)
    {
        global.ammo[increasePID, increaseWeapon] = 28;
    }
}

// Screen shake handling
if (!global.frozen)
{
    if (global.shakeTimer &gt; 0)
    {
        global.shakeTimer -= 1;
    }
    else
    {
        global.shakeFactorX = 0;
        global.shakeFactorY = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>cleanMem('clean');

setfrozen = 0;

if (global.endStageOnRoomEnd)
{
    stageEnd();
}
else if (global.decrementLivesOnRoomEnd)
{
    // lose a life
    if (global.inGame)
    {
        global.livesRemaining--;
    }
    global.decrementLivesOnRoomEnd = false;
    if (global.livesRemaining &lt; 0)
    {
        global.inGame = false;
    }
}

// objMegaman clean-up
with (objMegaman)
    instance_destroy();

// weapon clean up
for (i = 0; i &lt;= global.playerCount; i += 1)
{
    global.weapon[i] = 0;
}

global.lockBuster = false;

global.timeStopped = false;

application_surface_draw_enable(true);

// forcibly reset control locks
globalLockReset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// setup room, spawn players, etc.
joystick_connected = 0;
if (joystick_exists(1))
{
    joystick_connected = true;
}

// global.frozen = false;
global.aliveBosses = 0;
global.levelTimerRun = false;
global.lockTransition = false;
global.switchingSections = false;

global.keyCoinTotal = 0;
global.keyCoinCollected = 0;
global.keyNumber = 0;

global.nextRoom = 0;

view_wview[0] = min(global.screenWidth, room_width);
view_hview[0] = min(global.screenHeight, room_height);

room_speed = global.gameSpeed;

showhealth = 0;
global.roomTimer = 0;

// begin level if flag set
if (global.beginStageOnRoomBegin &amp;&amp; global.hasTeleported)
{
    // Delete this if you actually desire levels to begin by teleporter.
    // (Note that MaGMML-esque hub teleporters should not trigger this because they should not set hasTeleported to true.)
    printErr("Warning: A new stage began by teleporting in. This is probably not intended behaviour. See objGlobalControl:Room Start event for details.");
}

global.inGame = (instance_exists(objDefaultSpawn) || global.hasTeleported);

assert(!global.beginStageOnRoomBegin || global.inGame, "Began a stage but nowhere for player to spawn.");

if (global.inGame)
{
    if (DEBUG_SPAWN)
        show_debug_message("Level Start (objGlobalControl) " + roomExternalGetName(room));
    showhealth = 1;
    
    // set room settings
    view_enabled = true;
    view_visible[0] = true;
    room_speed = 60;
    
    // quadrant size
    for (i = 0; i &lt;= 7; i += 1)
    {
        if (string_pos("bgQuad", background_get_name(background_index[i])) == 1)
        {
            global.quadWidth = background_get_width(background_index[i]);
            global.quadHeight = background_get_height(background_index[i]);
            global.quadMarginTop = (global.quadHeight - view_hview[0]) / 2;
            global.quadMarginBottom = global.quadMarginTop;
            background_index[i] = -1;
        }
    }
    
    view_wview[0] = global.quadWidth;
    
    // Destroy collected pickups
    var str, slash, totalPickups;
    
    totalPickups = ds_list_size(pickups);
    for (var i = 0; i &lt;= totalPickups; i += 1)
    {
        str = ds_list_find_value(pickups, i);
        if (!is_string(str))
        {
            break;
        }
        slash = string_pos('/', str);
        if (room == real(string_copy(str, 1, slash - 1)))
        {
            with (real(string_delete(str, 1, slash)))
            {
                visible = 0;
                instance_destroy();
            }
        }
    }
    
    // Place section borders
    for (var v = 0; v &lt; room_height; v += global.quadHeight)
        for (var i = 0; i &lt; room_width; i += global.quadWidth)
        {
            with (instance_create(i, v, objStopScrollingVertical))
            {
                image_xscale = global.quadWidth / sprite_get_width(sprite_index);
            }
        }
    
    // Delete vertical border to make vertical scrolling possible
    with (objStopScrollingVertical)
    {
        if (place_meeting(x, y, objSectionFreeVerticalScrolling))
        {
            instance_destroy();
        }
    }
    
    // Connect Horizontal borders
    /*with (objStopScrollingHorizontal)
    {
        if (!place_meeting(x, y - 12, object_index))
        {
            while (place_meeting(x, y + 12, object_index))
            {
                with (instance_place(x, y + 12, object_index))
                {
                    other.image_yscale += image_yscale;
                    instance_destroy();
                }
            }
        }
    }*/
    
    ds_list_clear(global.borderlist);
    
    with (objStopScrollingHorizontal)
    {
        ds_list_add(global.borderlist, "h" + string(x) + "s" + string(y) + "e" + string(y + sprite_height));
        instance_destroy();
    }
    with (objStopScrollingVertical)
    {
        ds_list_add(global.borderlist, "v" + string(y) + "s" + string(x) + "e" + string(x + sprite_width));
        instance_destroy();
    }
    
    // determine starting location
    var spawn_x, spawn_y;
    
    // three ways to enter a room: teleporting, respawning, or level start
    if (global.hasTeleported)
    {
        // just teleported in
        if (global.teleportX || global.teleportY)
        {
            spawn_x = global.teleportX;
            spawn_y = global.teleportY;
        } // if coordinates were not specified, use the DefaultSpawn coordinates
        else
        {
            assert(instance_exists(objDefaultSpawn));
            spawn_x = objDefaultSpawn.x;
            spawn_y = objDefaultSpawn.y;
        }
    }
    else 
    {
        if (global.checkpoint == room)
        {
            // respawn after death
            spawn_x = global.checkpointX;
            spawn_y = global.checkpointY;
            
            // reset health
            for (var i = 0; i &lt; global.playerCount; i++)
            {
                global.playerHealth[i] = 28;
                global.gearCharge[i] = 0;
                global.gearPower[i] = 0;
                global.copyData = COPYDATA_NORMAL;
                global.playerVirus = 0
                global.spellCards = 3; //START
                global.spellCardsEnergy = 0
                global.activeCard = -1;
                global.activeCardDur = 0;
                global.gearSpeed[i] = 0;
                global.gearDouble[i] = 0;
                global.gearOverCharge[i] = 0;
            }
        }
        else
        {
            // Level start. Use default spawn location.
            global.checkpoint = room;
            global.checkpointX = objDefaultSpawn.x;
            global.checkpointY = objDefaultSpawn.y;
            global.respawnAnimation = objDefaultSpawn.respawnAnimation;
            global.freeMovement = false;
            if (instance_exists(objMegaman))
            {
                objMegaman.showDuringReady = objDefaultSpawn.showDuringReady;
                objMegaman.skipReady = objDefaultSpawn.skipReady;
            }
            spawn_x = global.checkpointX;
            spawn_y = global.checkpointY;
        
            stageStart();
        }
    }
    
    // Create players
    for (var i = 0; i &lt; global.playerCount; i += 1)
    {
        if (global.playerHealth[i] &lt;= 0)
        {
            continue;
        }
        
        with (instance_create(spawn_x, spawn_y, objMegaman))
        {
            playerID = i;
            readyTimer -= playerID * 12;
            
            if (global.hasTeleported)
            {
                showReady = false;
                teleporting = true;
                landy = y;
            }
            else
            {
                // teleport in
                showReady = true;
                readyTimer = (72 / 2 * skipReady)//0;
                canHit = false;
            }
            
            teleportLock = lockPoolLock(
                localPlayerLock[PL_LOCK_MOVE],
                localPlayerLock[PL_LOCK_PHYSICS],
                localPlayerLock[PL_LOCK_SHOOT],
                localPlayerLock[PL_LOCK_CLIMB],
                localPlayerLock[PL_LOCK_GEAR],
                localPlayerLock[PL_LOCK_CHARGE],
                localPlayerLock[PL_LOCK_PAUSE],
                localPlayerLock[PL_LOCK_TURN],
                localPlayerLock[PL_LOCK_GRAVITY]
                );
            
            playerPalette();
        }
    }
    
    // combine objects to save on CPU
    combineObjects(objSolid);
    combineObjects(objSpike);
    combineObjects(objDamageSpike);
    combineObjects(objIce);
    combineObjects(objWater);
    combineObjects(objStandSolid);
    combineObjects(objTopSolid, true, false);
    combineObjects(objLadder, false, true);
    with (prtBossDoor)
        event_user(3);
    
    setSection(spawn_x, spawn_y, 1);
    playerCamera(1);
    
    // defer deactivating objects until after room start
    // this allows objects with room start events to run those
    var activate;
    activate[0] = 2;
    activate[1] = 1;
    defer(ev_step, ev_step_begin, depth, reAndDeactivateObjects, activate);
    with (prtEntity)
    {
        beenOutsideView = true;
        dead = true;
    }
    global.hasTeleported = false;
    
    
        var i = instance_create(0, 0, objMapper)
        with (i)
        {
            event_user(0);
        }
}

// if the new room's view size is different, adjust the screen size accordingly
if (surface_get_width(application_surface) != view_wview[0] * global.screensize
    || surface_get_height(application_surface) != view_hview[0] * global.screensize)
{
    setScreenSize(global.screensize, false);
}

// next room should not launch a new level
global.beginStageOnRoomBegin = false;
global.beginHubOnRoomBegin = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Save game
saveLoadOptions(true);
saveLoadGame(true);

// End cleanMem
cleanMem('clear');
cleanMem('free');
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_halign(fa_center);

if (global.showControllerOverlay)
{
    drawControllerOverlay(view_xview + view_wview - 28, view_yview + view_hview);
}

// Show FPS
if (global.showFPS)
{
    draw_set_halign(fa_right);
    draw_set_valign(fa_bottom);
    draw_text(view_xview + view_wview - (28 - ((global.showControllerOverlay == 0) * 28)) - ((global.showControllerOverlay == 1) * 4), view_yview + view_hview,
        string(fps));
}

draw_set_valign(fa_top);
draw_set_halign(fa_center);

// Save icon
if (saveTimer &gt;= 0)
{
    saveTimer -= 0.5;
    draw_sprite(sprSavingIcon, saveFrame, view_xview + 2 + 7, view_yview + 224 - 16 + 5);
    draw_text(view_xview + 16 + 32 + 4 + 2, view_yview + 224 - 10 - 4, "SAVING...");
    
    if (saveTimer mod 4 == 0)
    {
        saveFrame = !saveFrame;
    }
}

// Screen iFrames
draw_set_color(c_white);
draw_set_alpha(1);
if (!global.frozen)
{
    if (global.flashTimer &gt; 0)
    {
        global.flashTimer -= 1;
        draw_sprite_ext(sprDot, image_index, view_xview, view_yview, view_wview, view_hview, image_angle, image_blend, image_alpha);
    }
}

draw_set_color(c_white);
draw_set_halign(fa_left);
draw_set_valign(fa_top);

if (fadeAlpha &gt; 0)
{
    draw_sprite_ext(sprDot, 0, view_xview, view_yview, view_wview, view_hview, 0, c_black, fadeAlpha);
}

depth = depthstart;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Commented Out Code
/*if (global.gearOverCharge[z])
                {
                    var gearOverChargeFlash = global.nesPalette[5];
                    draw_sprite_ext(sprHealthbarBackground, 0, dx, dy - 8, 1, 1,
                        image_angle, gearOverChargeFlash, image_alpha);
                }
                else
                {
                    draw_sprite_ext(sprHealthbarBackground, 0, dx , dy - 8, 1, 1,
                        image_angle, c_black, image_alpha);
                }
                var gearPcol = global.nesPalette[13];
                var gearScol = global.nesPalette[40];
                if (global.gearPower[z] &amp;&amp; !global.gearDouble[z])
                {
                    gearPcol = global.nesPalette[5];
                    gearScol = global.nesPalette[18];                
                }
                if (global.gearSpeed[z] &amp;&amp; !global.gearDouble[z])
                {
                    gearPcol = global.nesPalette[1];
                    gearScol = global.nesPalette[14];    
                
                }
                if (global.gearDouble[z])
                {
                    gearPcol = global.nesPalette[5];
                    gearScol = global.nesPalette[27];    
                
                }
                for (i = 1; i &lt;= global.gearCharge[z]; i += 1)
                {
                    draw_sprite_ext(sprHealthbarPrimary, 0, dx + i * 2 - 1,  dy - 8 + 1,
                        1, 1, 0, gearPcol, 1);
                    draw_sprite_ext(sprHealthbarSecondary, 0, dx + i * 2 - 1,  dy - 8 + 1,
                        1, 1, 0, gearScol, 1);
                }*/
                
                /*draw_sprite_ext(sprHPHorizontal, 0, dx , dy + 8 + 3 + 1 + 16 - 5 + 11, 1, 1, image_angle, make_color_rgb(255,0,255), image_alpha);
                draw_sprite_ext(sprHPHorizontal, 5, dx , dy + 8 + 3 + 1 + 16 - 5 + 11, 1, 1, image_angle, make_color_rgb(255,0,255), image_alpha);
                draw_sprite_ext(sprHPHorizontal, 4, dx , dy + 8 + 3 + 1 + 16 - 5 + 11, 1, 1, image_angle, make_color_rgb(200,0,200), image_alpha);
                draw_sprite_ext(sprHPHorizontal, 2, dx , dy + 8 + 3 + 1 + 16 - 5 + 11, 1, 1, image_angle, make_color_rgb(200,0,200), image_alpha);
                
                for (i = 1; i &lt;= 28; i += 1)
                {                       
                    draw_sprite_ext(sprHorizontalBarUnitDark, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11,
                        1, 1, 0, global.nesPalette[17], 1);
                    draw_sprite_ext(sprHorizontalBarUnitDark, 1, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11,
                        1, 1, 0, global.nesPalette[30], 1);
                }             
                for (i = 1; i &lt;= ceil(global.playerExp / global.playerExpMax * 28); i += 1)
                {
                    draw_sprite_ext(sprHorizontalBarUnit, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11,
                        1, 1, 0, global.nesPalette[17], 1);
                    draw_sprite_ext(sprHorizontalBarUnit, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11,
                        1, 1, 0, global.nesPalette[30], 1);
                }
                if levelupTimer &amp;&amp; (floor(global.roomTimer / 3 mod 2))
                {
                    draw_set_halign(fa_center)
                    draw_set_color(c_purple)
                    draw_text_transformed(dx + 14 * 2, dy + 8 + 3 + 1 + 16 - 5 + 11 + 1, "LEVEL UP", 0.75, 0.75, 0)
                    draw_set_halign(fa_left)
                    draw_set_color(c_white)
                }
                else if levelupTimer &amp;&amp; !(floor(global.roomTimer / 3 mod 2))
                {
                    draw_set_halign(fa_center)
                    draw_set_color(c_white)
                    draw_text_transformed(dx + 14 * 2, dy + 8 + 3 + 1 + 16 - 5 + 11 + 1, "LEVEL UP", 0.75, 0.75, 0)
                    draw_set_halign(fa_left)
                    draw_set_color(c_white)
                }*/
                
                
                
                /*draw_sprite_ext(sprHPHorizontal, 0, dx , dy + 8 + 3 + 1 + 16 - 5 + 24 + 11, 1, 1, image_angle, make_color_rgb(255,0,255), image_alpha);
                
                draw_text_colour(dx , dy + 8 + 3 + 1 + 16 - 5 + 24, "P", c_red, c_red, c_red, c_red, 1);
                draw_text_colour(dx , dy + 8 + 3 + 1 + 16 - 5 + 24, "   D", c_white, c_white, c_white, c_white, 1);
                draw_text_colour(dx , dy + 8 + 3 + 1 + 16 - 5 + 24, "      S", c_blue, c_blue, c_blue, c_blue, 1);
        
                for (i = 1; i &lt;= 28; i += 1)
                {                       
                    draw_sprite_ext(sprHealthbarPrimary, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 1 + 24,
                        1, 1, 0, make_colour_rgb(graycolor1, graycolor1, graycolor1), 1);
                    draw_sprite_ext(sprHealthbarSecondary, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 1 + 24,
                        1, 1, 0, make_colour_rgb(graycolor2, graycolor2, graycolor2), 1);
                }             
                for (i = 1; i &lt;= ceil(global.playerExp / global.playerExpMax * 28); i += 1)
                {
                    draw_sprite_ext(sprHealthbarPrimary, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 1 + 24,
                        1, 1, 0, global.nesPalette[17], 1);
                    draw_sprite_ext(sprHealthbarSecondary, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 1 + 24,
                        1, 1, 0, global.nesPalette[30], 1);
                }
                if levelupTimer &amp;&amp; (floor(global.roomTimer / 3 mod 2))
                {
                    draw_set_halign(fa_center)
                    draw_set_color(c_purple)
                    draw_text_transformed(dx + 14 * 2, dy + 8 + 3 + 1 + 16 - 5 + 11 + 1 + 24, "LEVEL UP", 0.75, 0.75, 0)
                    draw_set_halign(fa_left)
                    draw_set_color(c_white)
                }
                else if levelupTimer &amp;&amp; !(floor(global.roomTimer / 3 mod 2))
                {
                    draw_set_halign(fa_center)
                    draw_set_color(c_white)
                    draw_text_transformed(dx + 14 * 2, dy + 8 + 3 + 1 + 16 - 5 + 11 + 1 + 24, "LEVEL UP", 0.75, 0.75, 0)
                    draw_set_halign(fa_left)
                    draw_set_color(c_white)
                }*/
                
                
                
                
                
                /*if global.activeCard == -1
                {
                for (i = 1; i &lt;= global.spellCardsEnergy; i += 1)
                {
                    draw_sprite_ext(sprHealthbarPrimary, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 1,
                        1, 1, 0, global.nesPalette[1], 1);
                    draw_sprite_ext(sprHealthbarSecondary, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 1,
                        1, 1, 0, global.nesPalette[14], 1);
                }
                }
                else
                {                
                for (i = 1; i &lt;= ceil(global.activeCardDur / global.activeCardDurMax * 28); i += 1)
                {
                    draw_sprite_ext(sprHealthbarPrimary, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 1,
                        1, 1, 0, global.nesPalette[24], 1);
                    draw_sprite_ext(sprHealthbarSecondary, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 1,
                        1, 1, 0, global.nesPalette[37], 1);
                }
                
                draw_text(dx, dy + 8 + 3 + 1 + 16 - 5 + 11 + 11, string(global.cardAbrv[global.activeCard]));
                }*/
                

                /*if global.playerHealth[z] &lt;= 7 &amp;&amp; (floor(global.roomTimer / 2 mod 2))
                {
                draw_sprite_ext(sprHPHorizontal, 1, dx, dy + 8 + 3, 1, 1,
                    image_angle, c_red, image_alpha);
                }
                else
                {
                draw_sprite_ext(sprHPHorizontal, 1, dx, dy + 8 + 3, 1, 1,
                    image_angle, make_colour_rgb(0, 255, 123), image_alpha);
                }*/
                /*for (i = 1; i &lt;= c; i += 1)
                {
                    draw_sprite_ext(sprHealthbarPrimary, 0, dx - 8 + 1, dy
                        + (sprite_get_height(sprHealthbarBackground) - i * 2),
                        1, 1, 0, global.primaryCol[z], 1);
                    draw_sprite_ext(sprHealthbarSecondary, 0, dx - 8 + 1, dy
                        + (sprite_get_height(sprHealthbarBackground) - i * 2),
                        1, 1, 0, global.secondaryCol[z], 1);
                }
                if (global.infiniteEnergy[global.weapon[z]])
                {
                    draw_sprite_ext(sprInfinityMarkVertical, 0, dx - 8, dy + 28, 1,
                        1, 0, c_white, 1);
                    draw_sprite_ext(sprInfinityMarkVerticalPrimary, 0, dx - 8,
                        dy + 28, 1, 1, 0, global.primaryCol[z], 1);
                    draw_sprite_ext(sprInfinityMarkVerticalSecondary, 0, dx - 8,
                        dy + 28, 1, 1, 0, global.secondaryCol[z], 1);
                }*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player Health (NEW)
if (showhealth)
{
    var dx = view_xview + 16;
    //var dy = view_yview + 17;
    var dy = view_yview + 27 - 16;
    
    var graycolor1 = 45
    
    var graycolor2 = 61
    
    draw_enable_alphablend(true);
    
    /// Draw HUD
    draw_set_halign(fa_center)
    draw_set_valign(fa_top)
    draw_set_color(c_white);
    /*if global.arcadeMode == false{
    draw_set_font(global.font); //view_yview + view_hview
    draw_text_transformed(view_xview+128, view_yview+4 - 0, zeroPad(floor(global.levelTimer/3600) mod 60,2)+"'"+zeroPad(floor(global.levelTimer/60) mod 60,2)+'"'+zeroPad(floor(global.levelTimer/1) mod 60,2), 1, 1, 0);
    //draw_text(view_xview+128, view_yview + view_hview - 8, zeroPad(floor(global.levelTimer/3600) mod 60,2)+"'"+zeroPad(floor(global.levelTimer/60) mod 60,2)+'"'+zeroPad(floor(global.levelTimer/1) mod 60,2));
    }
    else{
    draw_set_font(global.timerFont);
    draw_text_transformed_colour(view_xview+128, view_yview + 25, zeroPad(floor(global.levelTimer/60) mod 100,2), 0.5, 0.5, 0, global.nesPalette[timerColor], global.nesPalette[timerColor], global.nesPalette[timerColor], global.nesPalette[timerColor], 1);
    }
    draw_set_font(global.font);
    
    //draw_text(view_xview+128, view_yview + view_hview - 8 - 10, zeroPad(string(global.levelScore),7));
    draw_text_transformed(view_xview+128, view_yview+4 + 12 - 0, zeroPad(string(global.levelScore),7), 1, 1, 0);*/
    
    
    for (z = 0; z &lt; global.playerCount; z += 1)
    {
        
            var pcol
            var scol 
            if ((global.gearSpeed[z] || global.gearPower[z]) &amp;&amp; global.gearOverCharge[z])
            {
                pcol = make_color_rgb(200, 0, 0);
                scol = make_color_rgb(255, 0, 0);
            }
            else
            {
                pcol = make_color_rgb(252, 228, 160);
                scol = c_white;
            }
        
        
        draw_sprite_ext(sprHPHorizontal, 0, dx, dy, 1, 1, image_angle,
            pcol, image_alpha);
        draw_sprite_ext(sprHPHorizontal, 5, dx, dy, 1, 1, image_angle,
            pcol, image_alpha);
        draw_sprite_ext(sprHPHorizontal, 1, dx, dy, 1, 1, image_angle,
            scol, image_alpha);
        draw_sprite_ext(sprHPHorizontal, 2, dx, dy, 1, 1, image_angle,
            scol, image_alpha);
            
        /*if global.playerVirus &gt;= global.playerHealth[z]
        {
            draw_sprite_ext(sprHPHorizontal, 0, dx, dy, 1, 1,
                image_angle, make_colour_rgb(255, 0, 255), image_alpha);
            draw_sprite_ext(sprHPHorizontal, 2, dx, dy, 1, 1,
                image_angle, make_colour_rgb(164, 0, 164), image_alpha);
            draw_sprite_ext(sprHPHorizontal, 4, dx, dy, 1, 1,
                image_angle, make_colour_rgb(164, 0, 164), image_alpha);
            draw_sprite_ext(sprHPHorizontal, 5, dx, dy, 1, 1,
                image_angle, make_colour_rgb(255, 0, 255), image_alpha);
        }*/
        if global.playerHealth[z] &lt;= 7 &amp;&amp; (floor(global.roomTimer / 3 mod 3))
        {
            draw_sprite_ext(sprHPHorizontal, 0, dx, dy, 1, 1,
                image_angle, c_red, image_alpha);
            draw_sprite_ext(sprHPHorizontal, 2, dx, dy, 1, 1,
                image_angle, c_red, image_alpha);
            draw_sprite_ext(sprHPHorizontal, 4, dx, dy, 1, 1,
                image_angle, make_colour_rgb(164, 0, 0), image_alpha);
            draw_sprite_ext(sprHPHorizontal, 5, dx, dy, 1, 1,
                image_angle, c_red, image_alpha);
        }
        
                
                
        //draw_text(dx, dy + 60, global.livesRemaining);
        draw_set_halign(fa_right)
        draw_set_valign(fa_top)
        draw_set_color(c_white);
        /*if (global.livesEnabled)
        {
            draw_text(dx + 8, dy + 57, global.livesRemaining);
        }*/
        if (global.livesEnabled)
        {
            draw_text(dx - 2, dy, string(global.livesRemaining));
        }
        
        draw_set_halign(fa_left)
        //draw_sprite(sprSpellCard, 0, dx, dy + 8 + 3 + 1 + 16 - 5)
        //draw_text(dx + 10, dy + 8 + 3 + 1 + 16 - 5, string(global.spellCards)+"/"+string(global.spellCardsMax));
        
        if (global.gearPower[z])
        { 
            draw_sprite_ext(sprPowerup, 4, dx + 10, dy + 8 + 3 + 10 + 11, 0.5, 0.5, 0, c_white, 1)
        }
        else if (global.gearOverCharge[z])
        { 
            draw_sprite_ext(sprPowerup, 7, dx + 10, dy + 8 + 3 + 10 + 11, 0.5, 0.5, 0, c_white, 1)
        }
        else
        { 
            draw_sprite_ext(sprPowerup, 1, dx + 10, dy + 8 + 3 + 10 + 11, 0.5, 0.5, 0, c_white, 1)
        }
        
        draw_sprite_ext(sprPowerup, 3, dx + 10 + 13, dy + 8 + 3 + 10 + 11, 0.5, 0.5, 0, c_white, 1)
        
        if (global.gearSpeed[z])
        { 
            draw_sprite_ext(sprPowerup, 5, dx + 10 + 13 + 13, dy + 8 + 3 + 10 + 11, 0.5, 0.5, 0, c_white, 1)
        }
        else if (global.gearOverCharge[z])
        { 
            draw_sprite_ext(sprPowerup, 8, dx + 10 + 13 + 13, dy + 8 + 3 + 10 + 11, 0.5, 0.5, 0, c_white, 1)
        }
        else
        { 
            draw_sprite_ext(sprPowerup, 2, dx + 10 + 13 + 13, dy + 8 + 3 + 10 + 11, 0.5, 0.5, 0, c_white, 1)
        }
        
        
        if (!global.gearOverCharge[z])
        {    
        
        draw_sprite_ext(sprHPHorizontal, 0, dx, dy + 21 + 16 + 11, 1, 1, image_angle,
            make_color_rgb(120,120,120), image_alpha);
        draw_sprite_ext(sprHPHorizontal, 5, dx, dy + 21 + 16 + 11, 1, 1, image_angle,
            make_color_rgb(120,120,120), image_alpha);
        draw_sprite_ext(sprHPHorizontal, 4, dx, dy + 21 + 16 + 11, 1, 1, image_angle,
            make_color_rgb(200,200,200), image_alpha);
        draw_sprite_ext(sprHPHorizontal, 2, dx, dy + 21 + 16 + 11, 1, 1, image_angle,
            make_color_rgb(200,200,200), image_alpha);
            
        for (i = 1; i &lt;= 28; i += 1)
            {
                draw_sprite_ext(sprHorizontalBarUnitDark, 0, dx + i * 2 - 1,
                    dy + 21 + 16 + 11,
                    1, 1, 0, make_color_rgb(120,120,120), 1);
                draw_sprite_ext(sprHorizontalBarUnitDark, 1, dx + i * 2 - 1,
                    dy + 21 + 16 + 11,
                    1, 1, 0, make_color_rgb(200,200,200), 1);
            }
        for (i = 1; i &lt;= global.gearCharge[z]; i += 1)
            {
                draw_sprite_ext(sprHorizontalBarUnit, 0, dx + i * 2 - 1,
                    dy + 21 + 16 + 11,
                    1, 1, 0, make_color_rgb(200,200,200), 1);
                draw_sprite_ext(sprHorizontalBarUnit, 1, dx + i * 2 - 1,
                    dy + 21 + 16 + 11,
                    1, 1, 0, make_color_rgb(255,255,255), 1);
            }
            
        }
        else
        {
        
        draw_sprite_ext(sprHPHorizontal, 0, dx, dy + 21 + 16 + 11, 1, 1, image_angle,
            make_color_rgb(120,0,0), image_alpha);
        draw_sprite_ext(sprHPHorizontal, 5, dx, dy + 21 + 16 + 11, 1, 1, image_angle,
            make_color_rgb(120,0,0), image_alpha);
        draw_sprite_ext(sprHPHorizontal, 4, dx, dy + 21 + 16 + 11, 1, 1, image_angle,
            make_color_rgb(200,0,0), image_alpha);
        draw_sprite_ext(sprHPHorizontal, 2, dx, dy + 21 + 16 + 11, 1, 1, image_angle,
            make_color_rgb(200,0,0), image_alpha);
            
        for (i = 1; i &lt;= 28; i += 1)
            {
                draw_sprite_ext(sprHorizontalBarUnitDark, 0, dx + i * 2 - 1,
                    dy + 21 + 16 + 11,
                    1, 1, 0, make_color_rgb(120,0,0), 1);
                draw_sprite_ext(sprHorizontalBarUnitDark, 1, dx + i * 2 - 1,
                    dy + 21 + 16 + 11,
                    1, 1, 0, make_color_rgb(200,0,0), 1);
            }    
        for (i = 1; i &lt;= global.gearCharge[z]; i += 1)
            {
                draw_sprite_ext(sprHorizontalBarUnit, 0, dx + i * 2 - 1,
                    dy + 21 + 16 + 11,
                    1, 1, 0, make_color_rgb(200,0,0), 1);
                draw_sprite_ext(sprHorizontalBarUnit, 1, dx + i * 2 - 1,
                    dy + 21 + 16 + 11,
                    1, 1, 0, make_color_rgb(255,0,0), 1);
            }                
            
        } 
        
        draw_set_color(make_color_rgb(255,0,255));
        //draw_text(dx , dy + 8 + 3 + 1 + 16 - 5, "LV. "+string(global.playerLVL));
        draw_set_color(c_white);
        
        /*draw_set_color(global.copyDataPrimary[global.copyData]);
        draw_text(dx, dy + 16, string(global.copyDataName[global.copyData]));
        draw_set_color(c_white);*/
        // Respawn indicators
            var donators = 1;
            var donate = 0;
            
            with (objMegaman)
            {
                if (global.playerHealth[playerID]
                    &gt; global.respawnDonateThreshold)
                {
                    donators += 1;
                }
            }
            with (objMegaman)
            {
                donate = floor(global.playerHealth[playerID] / donators)
                    * (global.playerHealth[playerID]
                    &gt; global.respawnDonateThreshold);
            }
        if (global.respawnTimer[z] &gt;= 0)
        {
            draw_set_color(c_white);
            draw_set_halign(fa_left);
            draw_set_valign(fa_middle);
            
            if (global.respawnTimer[z] &gt; 0)
            {
                draw_set_color(c_white);
                draw_text(dx, dy + 28, ceil(global.respawnTimer[z] / 60));
            }
            else if (global.respawnAllowed)
            {
                if donate &gt; 0
                {
                draw_set_color(c_white);
                draw_text(dx, dy + 28, "R#E#A#D#Y");
                }
                else
                {
                draw_set_color(c_red);
                draw_text(dx, dy + 28, "W#A#I#T");
                }
            }
            
            draw_set_valign(fa_top);
        }
        else
        {
            // normal healthbar
            var pcol
            var scol 
            if ((global.gearSpeed[z] || global.gearPower[z]) &amp;&amp; global.gearOverCharge[z])
            {
                pcol = make_color_rgb(200, 0, 0);
                scol = make_color_rgb(255, 0, 0);
            }
            else
            {
                pcol = make_color_rgb(252, 228, 160);
                scol = c_white;
            }
            //var pcol = make_color_rgb(252, 228, 160);
            //var scol = c_white;
            
            // low health -- red color
            if (global.playerHealth[z] &lt;= global.respawnDonateThreshold &amp;&amp; global.playerCount &gt; 1)
            {
                scol = pcol;
                pcol = global.nesPalette[5];
            }
            
            /*for (i = 1; i &lt;= ceil(global.playerHealth[z]); i += 1)
            {
                draw_sprite_ext(sprHealthbarPrimary, 0, dx + 1,
                    dy + (sprite_get_height(sprHealthbarBackground) - i * 2),
                    1, 1, 0, pcol, 1);
                draw_sprite_ext(sprHealthbarSecondary, 0, dx + 1,
                    dy + (sprite_get_height(sprHealthbarBackground) - i * 2),
                    1, 1, 0, scol, 1);
            }*/
            
            //for (i = 1; i &lt;= ceil(global.playerHealth[z] / global.playerMaxHealth[z] * 28); i += 1)
            for (i = 1; i &lt;= 28; i += 1)
            {
                draw_sprite_ext(sprHorizontalBarUnitDark, 0, dx + i * 2 - 1,
                    dy,
                    1, 1, 0, pcol, 1);
                draw_sprite_ext(sprHorizontalBarUnitDark, 1, dx + i * 2 - 1,
                    dy,
                    1, 1, 0, scol, 1);
            }
            for (i = 1; i &lt;= global.playerHealth[z]; i += 1)
            {
                draw_sprite_ext(sprHorizontalBarUnit, 0, dx + i * 2 - 1,
                    dy,
                    1, 1, 0, pcol, 1);
                draw_sprite_ext(sprHorizontalBarUnit, 1, dx + i * 2 - 1,
                    dy,
                    1, 1, 0, scol, 1);
            }
            
            for (i = 1; i &lt;= global.playerVirus; i += 1)
            {
                draw_sprite_ext(sprHealthbarSecondary, 0, dx + i * 2 - 1,
                    dy + 1,
                    1, 1, 0, global.nesPalette[30], 1);
            }
            
            var display = true;
            
            // Weapons
            if (global.weapon[z] != 0) // Weapon energy
            {
                c = round(global.ammo[z, global.weapon[z]]);
            }
            else // Charge bar
            {
                c = 0;
                with (objMegaman)
                {
                    if (playerID == other.z)
                    {
                        other.c = min(28, floor(chargeTimer) / 2);
                    }
                }
                display = global.chargeBar;
            }
            
            if (display)
            {
                /*draw_sprite_ext(sprHealthbarBackground, 0, dx - 8, dy, 1, 1,
                    image_angle, global.outlineCol[z], image_alpha);*/
                draw_sprite_ext(global.weaponIcon[z, global.weapon[z]], 0, dx - 10, dy + 8 + 3, 0.5, 0.5, image_angle, c_white, image_alpha);
                draw_sprite_ext(global.weaponIcon[z, global.weapon[z]], 1, dx - 10, dy + 8 + 3, 0.5, 0.5, image_angle, global.primaryCol[z], image_alpha);
                draw_sprite_ext(global.weaponIcon[z, global.weapon[z]], 2, dx - 10, dy + 8 + 3, 0.5, 0.5, image_angle, global.secondaryCol[z], image_alpha);
                draw_sprite_ext(global.weaponIcon[z, global.weapon[z]], 3, dx - 10, dy + 8 + 3, 0.5, 0.5, image_angle, c_white, image_alpha);
                draw_sprite_ext(sprHPHorizontal, 0, dx, dy + 8 + 3, 1, 1,
                    image_angle, global.primaryCol[z], image_alpha);
                draw_sprite_ext(sprHPHorizontal, 5, dx, dy + 8 + 3, 1, 1,
                    image_angle, global.primaryCol[z], image_alpha);
                draw_sprite_ext(sprHPHorizontal, 4, dx, dy + 8 + 3, 1, 1,
                    image_angle, global.secondaryCol[z], image_alpha);
                draw_sprite_ext(sprHPHorizontal, 2, dx, dy + 8 + 3, 1, 1,
                    image_angle, global.secondaryCol[z], image_alpha);
                for (i = 1; i &lt;= 28; i += 1)
                {
                    draw_sprite_ext(sprHorizontalBarUnitDark, 0, dx + i * 2 - 1,  dy + 8 + 3,
                        1, 1, 0, global.primaryCol[z], 1);
                    draw_sprite_ext(sprHorizontalBarUnitDark, 1, dx + i * 2 - 1, dy + 8 + 3,
                        1, 1, 0, global.secondaryCol[z], 1);
                }
                for (i = 1; i &lt;= c; i += 1)
                {
                    draw_sprite_ext(sprHorizontalBarUnit, 0, dx + i * 2 - 1,  dy + 8 + 3,
                        1, 1, 0, global.primaryCol[z], 1);
                    draw_sprite_ext(sprHorizontalBarUnit, 1, dx + i * 2 - 1, dy + 8 + 3,
                        1, 1, 0, global.secondaryCol[z], 1);
                }
                if (global.infiniteEnergy[global.weapon[z]])
                {
                    draw_sprite_ext(sprInfinityMarkVertical, 0, dx + 14, dy + 8 + 2, 1,
                        1, 0, c_white, 1);
                    draw_sprite_ext(sprInfinityMarkVertical, 0, dx + 14,
                        dy + 8 + 2, 1, 1, 0, global.primaryCol[z], 1);
                    draw_sprite_ext(sprInfinityMarkVertical, 0, dx + 14,
                        dy + 8 + 2, 1, 1, 0, global.secondaryCol[z], 1);
                }
                
                //SUBWEAPON
                draw_sprite_ext(global.subWeaponIcon[z, global.subWeapon[z]], 0, dx - 10, dy + 8 + 3 + 11, 0.5, 0.5, image_angle, c_white, image_alpha);
                draw_sprite_ext(global.subWeaponIcon[z, global.subWeapon[z]], 1, dx - 10, dy + 8 + 3 + 11, 0.5, 0.5, image_angle, global.subWeaponPrimaryColor[z], image_alpha);
                draw_sprite_ext(global.subWeaponIcon[z, global.subWeapon[z]], 2, dx - 10, dy + 8 + 3 + 11, 0.5, 0.5, image_angle, global.subWeaponSecondaryColor[z], image_alpha);
                draw_sprite_ext(global.subWeaponIcon[z, global.subWeapon[z]], 3, dx - 10, dy + 8 + 3 + 11, 0.5, 0.5, image_angle, c_white, image_alpha);
                draw_sprite_ext(sprHPHorizontal, 0, dx, dy + 8 + 3 + 11, 1, 1,
                    image_angle, global.subWeaponPrimaryColor[z], image_alpha);
                draw_sprite_ext(sprHPHorizontal, 5, dx, dy + 8 + 3 + 11, 1, 1,
                    image_angle, global.subWeaponPrimaryColor[z], image_alpha);
                draw_sprite_ext(sprHPHorizontal, 4, dx, dy + 8 + 3 + 11, 1, 1,
                    image_angle, global.subWeaponSecondaryColor[z], image_alpha);
                draw_sprite_ext(sprHPHorizontal, 2, dx, dy + 8 + 3 + 11, 1, 1,
                    image_angle, global.subWeaponSecondaryColor[z], image_alpha);
                for (i = 1; i &lt;= 28; i += 1)
                {
                    draw_sprite_ext(sprHorizontalBarUnitDark, 0, dx + i * 2 - 1,  dy + 8 + 3 + 11,
                        1, 1, 0, global.subWeaponPrimaryColor[z], 1);
                    draw_sprite_ext(sprHorizontalBarUnitDark, 1, dx + i * 2 - 1, dy + 8 + 3 + 11,
                        1, 1, 0, global.subWeaponSecondaryColor[z], 1);
                }
                for (i = 1; i &lt;= round(global.subWeaponAmmo[z, global.subWeapon[z]]); i += 1)
                {
                    draw_sprite_ext(sprHorizontalBarUnit, 0, dx + i * 2 - 1,  dy + 8 + 3 + 11,
                        1, 1, 0, global.subWeaponPrimaryColor[z], 1);
                    draw_sprite_ext(sprHorizontalBarUnit, 1, dx + i * 2 - 1, dy + 8 + 3 + 11,
                        1, 1, 0, global.subWeaponSecondaryColor[z], 1);
                }
                if (global.subWeaponInfiniteEnergy[global.subWeapon[z]])
                {
                    draw_sprite_ext(sprInfinityMarkVertical, 0, dx + 14, dy + 8 + 2 + 11, 1,
                        1, 0, c_white, 1);
                    draw_sprite_ext(sprInfinityMarkVertical, 0, dx + 14,
                        dy + 8 + 2 + 11, 1, 1, 0, global.subWeaponPrimaryColor[z], 1);
                    draw_sprite_ext(sprInfinityMarkVertical, 0, dx + 14,
                        dy + 8 + 2 + 11, 1, 1, 0, global.subWeaponSecondaryColor[z], 1);
                }
                
                
                
                
                
                var enemyPCol = make_color_rgb(200, 0, 0);
                var enemySCol = make_color_rgb(255, 0, 0);;
            //draw_sprite(sprEnemyIcon, global.enemyMug, dx + 4, dy + 28 + 8)  
            //draw_text(dx + 32, dy + 22 + 16, global.enemyName)      
            if (global.enemyTime &gt; 0)
            {
            //draw_sprite(sprEnemyIcon, global.enemyMug, dx + 4, dy + 28 + 8)  
            //draw_text_transformed(dx, dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 - 8 + 11, "("+string(global.enemyLevel)+") "+global.enemyName, 0.75, 0.75, 0)   
            draw_text_transformed(dx, dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 - 8 + 11, global.subWeaponName[0], 0.75, 0.75, 0)                  
            //if (ceil(global.enemyHP / global.enemyMaxHP * 28) &gt;= 1)      
            if (global.enemyHP &gt; 0)
            {
            draw_sprite_ext(sprHPHorizontal, 0, dx, dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 11, 1, 1, image_angle,
            enemyPCol, image_alpha);   
            draw_sprite_ext(sprHPHorizontal, 5, dx, dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 11, 1, 1, image_angle,
            enemyPCol, image_alpha);   
            draw_sprite_ext(sprHPHorizontal, 4, dx, dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 11, 1, 1, image_angle,
            enemySCol, image_alpha);   
            draw_sprite_ext(sprHPHorizontal, 2, dx, dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 11, 1, 1, image_angle,
            enemySCol, image_alpha);            
            
            for (i = 1; i &lt;= 28; i += 1)
            {                       
                draw_sprite_ext(sprHorizontalBarUnitDark, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 11,
                    1, 1, 0, enemyPCol, 1);
                draw_sprite_ext(sprHorizontalBarUnitDark, 1, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 11,
                    1, 1, 0, enemySCol, 1);
            }    
            for (i = 1; i &lt;= min(28, ceil(global.enemyHP / global.enemyMaxHP * 28)); i += 1)
            {
                draw_sprite_ext(sprHorizontalBarUnit, 0, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 11, 1, 1, 0, enemyPCol, 1);
                draw_sprite_ext(sprHorizontalBarUnit, 1, dx + i * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 11, 1, 1, 0, enemySCol, 1);
            }
            draw_set_halign(fa_center);
            
            if string_length(string_format(global.enemyHP,string_length(string(floor(global.enemyHP))),1)+"/"+string(global.enemyMaxHP)) &gt; 8
            {
                draw_text_transformed(dx + 14 * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 1 + 11, string_format(global.enemyHP,string_length(string(global.enemyHP)),1)+"/"+string(global.enemyMaxHP), 0.5, 0.5, 0)
            }
            else
            {
                draw_text_transformed(dx + 14 * 2 - 1,  dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 1 + 11, string_format(global.enemyHP,string_length(string(global.enemyHP)),1)+"/"+string(global.enemyMaxHP), 0.75, 0.75, 0)
            }
            
            draw_set_halign(fa_left);
            }
            else
            {
                draw_set_halign(fa_left);
                draw_text_colour(dx, dy + 8 + 3 + 1 + 16 - 5 + 11 + 11 + 20 + 11, "DESTROYED", make_color_rgb(255, 0, 0),make_color_rgb(255, 0, 0),make_color_rgb(255, 0, 0),make_color_rgb(255, 0, 0),1)
            }
            }
                
            }
        }
        
        dx += 24;
    }
    
    var bossFade = 0;
    var healthIndex = 0;
    with (prtBoss) // Boss healthbars
    {
        /*if (!quickSpawn&amp;&amp;drawHealthBar &amp;&amp; healthParent == -1)
        {
            var dxx = dx + ((healthIndex - 1) * 8); // Multibosses
            
            // Initial black bg for healthbar
            draw_sprite_ext(sprHealthbarBackground, 0, dxx, dy, 1, 1, 0, c_black, 1);
            
            // Choose color to draw
            var currentExtraHealthBar = 0;
            var myPrimaryColor, mySecondaryColor;
            var _currentHealth = 0;
            
            if (fillingHealthBar) //Intro health bar
            {
                _currentHealth = ceil(healthBarHealth);
            }
            else 
            {
                if (shareMode==1) //Combine health bars if needed
                {
                    with (prtBoss)
                    {
                        if (id == other.id || (healthParent==other.id &amp;&amp; drawHealthBar))
                        {
                            _currentHealth += healthpoints;
                        }
                    }
                }
                else
                {
                    _currentHealth = healthpoints;
                }
            }
            // draw the health within the healthbar.
            for (i = 1; i &lt;= ceil(_currentHealth); i += 1;)
            {
                // If the boss has more than 28 health, use this math to find out what 'layer' of
                // health the boss is currently on. It's i-1/28 because if it was i/28, it would start
                // a new health layer at the max health (28) rather than 1 over, when it should
                // overflow.
                
                if ((i mod 28) == 1) // Set new colors for the health bar
                {
                    currentExtraHealthBar = ((i - 1) / 28);
                    if (manualColors)
                    {
                        myPrimaryColor = healthBarPrimaryColor[currentExtraHealthBar + 1];
                        mySecondaryColor = healthBarSecondaryColor[currentExtraHealthBar + 1];
                    }
                    else
                    {
                        // if the colors chosen are higher numbered than valid colors on the NES palette, default to the last in the index (black)
                        myPrimaryColor = global.nesPalette[min(54, (healthBarPrimaryColor[1] + (healthBarColorSkip * (currentExtraHealthBar))))];
                        mySecondaryColor = global.nesPalette[min(54, (healthBarSecondaryColor[1] + (healthBarColorSkip * (currentExtraHealthBar))))];
                    }
                }
                
                // now actually draw the pellets themselves, using all the info we've gatehred.
                draw_sprite_ext(sprHealthbarPrimary, 0, dxx + 1,
                    dy + (sprite_get_height(sprHealthbarBackground)) - ((i - (currentExtraHealthBar * 28)) * 2),
                    1, 1, 0, myPrimaryColor, 1);
                draw_sprite_ext(sprHealthbarSecondary, 0, dxx + 1,
                    dy + (sprite_get_height(sprHealthbarBackground)) - ((i - (currentExtraHealthBar * 28)) * 2),
                    1, 1, 0, mySecondaryColor, 1);
            }
            healthIndex += 1;
        }
        
        if (isIntro &amp;&amp; introType == 3) // MM6 intro fading
        {
            bossFade = max(bossFade, introFade);
        }*/
        if (!quickSpawn&amp;&amp;drawHealthBar &amp;&amp; healthParent == -1)
        {
            var dxx = dx + ((healthIndex - 1) * 8); // Multibosses
            var dyy = dy + ((healthIndex - 0) * 27); // Multibosses
            
            // Initial black bg for healthbar
            //draw_sprite_ext(sprHPHorizontal, 0, dx + 152 - 16, dyy, 1, 1, 0, c_white, 1);
            
            // Choose color to draw
            var currentExtraHealthBar = 0;
            var myPrimaryColor, mySecondaryColor;
            var _currentHealth = 0;
            var _mugshot = 0;
            var _name = "";
            var _nameCol = c_red;
            //var _level = 0;
            
            if (fillingHealthBar) //Intro health bar
            {
                _currentHealth = ceil(healthBarHealth);
            }
            else 
            {
                if (shareMode==1) //Combine health bars if needed
                {
                    with (prtBoss)
                    {
                        if (id == other.id || (healthParent==other.id &amp;&amp; drawHealthBar))
                        {
                            _currentHealth += healthpoints;
                            _name = name;
                            _mugshot = bossMug;
                            _nameColPal = nameColPal;
                            _nameCol = nameCol;
                            //_level = level;
                        }
                    }
                }
                else
                {
                    _currentHealth = healthpoints;
                    _name = name;
                    _mugshot = bossMug;
                    _nameColPal = nameColPal;
                    _nameCol = nameCol;
                    //_level = level;
                }
            }
            draw_set_halign(fa_right);
            if nameColPal
            {
                draw_set_color(global.nesPalette[healthBarPrimaryColor[1]])
                draw_sprite_ext(sprHPHorizontal, 0, dx + 152 - 16 - 4, dyy + 1, 1, 1, 0, global.nesPalette[healthBarPrimaryColor[1]], 1);
                draw_sprite_ext(sprHPHorizontal, 5, dx + 152 - 16 - 4, dyy + 1, 1, 1, 0, global.nesPalette[healthBarPrimaryColor[1]], 1);
                draw_sprite_ext(sprHPHorizontal, 4, dx + 152 - 16 - 4, dyy + 1, 1, 1, 0, global.nesPalette[healthBarSecondaryColor[1]], 1);
                draw_sprite_ext(sprHPHorizontal, 2, dx + 152 - 16 - 4, dyy + 1, 1, 1, 0, global.nesPalette[healthBarSecondaryColor[1]], 1);
            }
            else
            {
                draw_set_color(healthBarPrimaryColor[1])
                draw_sprite_ext(sprHPHorizontal, 0, dx + 152 - 16 - 4, dyy + 1, 1, 1, 0, healthBarPrimaryColor[1], 1);
                draw_sprite_ext(sprHPHorizontal, 5, dx + 152 - 16 - 4, dyy + 1, 1, 1, 0, healthBarPrimaryColor[1], 1);
                draw_sprite_ext(sprHPHorizontal, 4, dx + 152 - 16 - 4, dyy + 1, 1, 1, 0, healthBarSecondaryColor[1], 1);
                draw_sprite_ext(sprHPHorizontal, 2, dx + 152 - 16 - 4, dyy + 1, 1, 1, 0, healthBarSecondaryColor[1], 1);
            }
            
            
            draw_sprite_ext(sprBossMugshots, bossMug, dx + 152 + 56 - 16, dyy, 0.5, 0.5, 0, c_white, 1);
            draw_text_transformed(dx + 152 + 56 - 16, dyy + 9 + 2, " " + string(name), 0.75, 0.75, 0)
            draw_set_color(c_white)
            // draw the health within the healthbar.
            
            for (i = 1; i &lt;= 28; i += 1)
            {           
                if nameColPal
                {            
                draw_sprite_ext(sprHorizontalBarUnitDark, 0, dx + 150 - 16 - 4 + 1 + (i * 2),  dyy + 1,
                    1, 1, 0, global.nesPalette[healthBarPrimaryColor[1]], 1);
                draw_sprite_ext(sprHorizontalBarUnitDark, 1, dx + 150 - 16 - 4 + 1 + (i * 2),  dyy + 1,
                    1, 1, 0, global.nesPalette[healthBarSecondaryColor[1]], 1);
                }      
                else
                {            
                draw_sprite_ext(sprHorizontalBarUnitDark, 0, dx + 150 - 16 - 4 + 1 + (i * 2),  dyy + 1,
                    1, 1, 0, healthBarPrimaryColor[1], 1);
                draw_sprite_ext(sprHorizontalBarUnitDark, 1, dx + 150 - 16 - 4 + 1 + (i * 2),  dyy + 1,
                    1, 1, 0, healthBarSecondaryColor[1], 1);
                }
            }
            for (i = 1; i &lt;= ceil(_currentHealth); i += 1;)
            {
                // If the boss has more than 28 health, use this math to find out what 'layer' of
                // health the boss is currently on. It's i-1/28 because if it was i/28, it would start
                // a new health layer at the max health (28) rather than 1 over, when it should
                // overflow.
                
                if ((i mod 28) == 1) // Set new colors for the health bar
                {
                    currentExtraHealthBar = ((i - 1) / 28);
                    if (manualColors)
                    {
                        myPrimaryColor = healthBarPrimaryColor[currentExtraHealthBar + 1];
                        mySecondaryColor = healthBarSecondaryColor[currentExtraHealthBar + 1];
                    }
                    else
                    {
                        // if the colors chosen are higher numbered than valid colors on the NES palette, default to the last in the index (black)
                        myPrimaryColor = global.nesPalette[min(54, (healthBarPrimaryColor[1] + (healthBarColorSkip * (currentExtraHealthBar))))];
                        mySecondaryColor = global.nesPalette[min(54, (healthBarSecondaryColor[1] + (healthBarColorSkip * (currentExtraHealthBar))))];
                    }
                }
                
                // now actually draw the pellets themselves, using all the info we've gatehred.
                //(sprite_get_height(sprHealthbarBackground)) - ((i - (currentExtraHealthBar * 28)) * 2
                draw_sprite_ext(sprHorizontalBarUnit, 0, dx + 208 - 16 + 1 - 4 + (i - (currentExtraHealthBar * 28)) * 2 * -1,  dyy + 1,
                    1, 1, 0, myPrimaryColor, 1);
                draw_sprite_ext(sprHorizontalBarUnit, 1, dx + 208 - 16 + 1 - 4 + (i - (currentExtraHealthBar * 28)) * 2 * -1,  dyy + 1,
                    1, 1, 0, mySecondaryColor, 1);
            }
            healthIndex += 1;
        }
        
        if (isIntro &amp;&amp; introType == 3) // MM6 intro fading
        {
            bossFade = max(bossFade, introFade);
        }
    }
    
    draw_enable_alphablend(true);
    
    if (bossFade &gt; 0)
    {
        draw_sprite_ext(sprDot, 0, view_xview, view_yview, view_wview, view_hview, 0, c_black, bossFade);
    }
    
    // reset position
    var dx = view_xview + 16;
    var dy = view_yview + 17;
    
    // Keys
    for (i = 0; i &lt; global.keyNumber; i += 1)
    {
        draw_sprite_ext(sprKeyHud, 0, dx + 8, dy + (8 * i), 1, 1, 0, c_white, 1);
    }
    
    // Key coins
    for (i = 0; i &lt; global.keyCoinTotal; i += 1)
    {
        draw_sprite_ext(sprKeyCoinHUD, !(i &lt; global.keyCoinCollected),
            view_xview + (8 * i), view_yview + view_hview - 8, 1, 1, 0, c_white, 1);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
