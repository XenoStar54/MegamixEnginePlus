<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprMegaWaterS</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtBoss</parentName>
  <maskName>sprCutMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Creation code (all optional):
event_inherited();

healthpointsStart = 28;
healthpoints = healthpointsStart;

customPose = true;
contactDamage = 3;

// Healthbar colours
healthBarPrimaryColor[1] = 9;
healthBarSecondaryColor[1] = 40;

// Music
music = "WilyTowerBossTheme.vgm";
musicType = "VGM";
musicTrackNumber = 0;
musicVolume = 1;
musicLoopSecondsStart = 0;
musicLoopSecondsEnd = 0;

// @cc
platformLeft = (x div view_wview[0]) * view_wview[0] + 80;

// @cc
platformRight = platformLeft + 96;

// @cc
platformTop = (y div view_hview[0]) * view_hview[0] + 112;

gravWater = 0.38 * grav; // The player's gravity in water
jumpSpeed = 4.75 + grav * 2; // Dunno why grav needs to be multiplied by 2, but MM jumps as high as in MM5 when doing so
jumpSpeedWater = 0.1;
walkSpeed = 1.3;
noDelay = false;
canSpear = true;

// enemy variables
phase = 0;
nextPhase = 0;
timer = 0;
counter = 0;
walkX = 0;
shield = noone;
lastAttacks = ds_list_create();

imgIndex = 0;
imgSpd = 0.17;

// Damage Table
enemyDamageValue(objBusterShot, 1);
enemyDamageValue(objBusterShotHalfCharged, 1);
enemyDamageValue(objBusterShotCharged, 2);
//enemyDamageValue(objBusterShotChargedProto, 2);

// mm1
enemyDamageValue(objRollingCutter, 0);
enemyDamageValue(objSuperArmBlockProjectile, 1);
enemyDamageValue(objSuperArmDebris, 1);
enemyDamageValue(objIceSlasher, 3);
enemyDamageValue(objHyperBomb, 3);
enemyDamageValue(objFireStorm, 1);
enemyDamageValue(objThunderBeam, 1);

// mm2
enemyDamageValue(objAirShooter, 0);
enemyDamageValue(objBubbleLead, 1);
enemyDamageValue(objCrashBomber, 1);
enemyDamageValue(objLeafShield, 1);
enemyDamageValue(objMetalBlade, 0);
enemyDamageValue(objQuickBoomerang, 1);
stopOnFlash = false;

// mm3
enemyDamageValue(objGeminiLaser, 1);
enemyDamageValue(objHardKnuckle, 1);
enemyDamageValue(objMagnetMissile, 1);
enemyDamageValue(objNeedleCannon, 1);
enemyDamageValue(objSearchSnake, 2);
enemyDamageValue(objShadowBlade, 1);
enemyDamageValue(objSparkShock, 1);
enemyDamageValue(objTopSpin, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(lastAttacks);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (entityCanStep())
{
    if (startIntro)
    {
        imgIndex = 5; // fall with arms up
        visible = true;
        calibrateDirection();
        canFillHealthBar = false;
        startIntro = false;
        isIntro = true;
        grav = 0;
        y -= view_hview[0];
    }
    else if (isIntro)
    {
        switch (phase)
        {
            // falling into the screen
            case 0:
                imgIndex = 2;
                y += 4;
                grav = 0;
                if (y &gt;= ystart)
                {
                    y = ystart;
                    imgIndex = 0;
                    phase++;
                }
                
                break;
            
            // pose
            case 1:
                timer++;
                switch (timer div 6)
                {
                    // animation
                    case 0: imgIndex = 0; break; // stand
                    case 1: imgIndex = 4; break; // crouch
                    case 2: imgIndex = 3; break; // crouch with arm up
                    case 3: imgIndex = 2; break; // jump????????
                    case 4: imgIndex = 3; break; // crouch with arm up
                    case 5: imgIndex = 1; break; // stand with arm up
                    
                    // end
                    default:
                        timer = 0;
                        phase = 0;
                        
                        isIntro = false;
                        canFillHealthBar = true;
                        grav = gravStart;
                        blockCollision = blockCollisionStart;
                        break;
                }
                
                break;
        }
    }
    
    if (isFight)
    {
        switch (phase)
        {
            // jump up to platform
            case 0:
                if (ground)
                {
                    xspeed = 0;
                    counter = 0;
                    imgIndex = 0;
                    
                    if (ycoll &gt; 0 || bbox_bottom &lt;= platformTop)
                    {
                        // landed on platform, start ai
                        xspeed = 0;
                        nextPhase = 1;
                        
                        // always start by moving
                        phase = 1;
                        noDelay = true;
                        canSpear = false;
                        
                        ds_list_add(lastAttacks, phase);
                    }
                    else
                    {
                        // initiate jump / walk from under platform
                        if (x &lt; platformLeft - 16)
                        {
                            yspeed = ySpeedAim(y, platformTop - (bbox_bottom - y) - 8, grav);
                            xspeed = xSpeedAim(x, y, platformLeft + 4, platformTop - (bbox_bottom - y),
                                yspeed, grav);
                            imgIndex = 5;
                            counter = xspeed; // lol reusing to persist xspeed
                            image_xscale = 1;
                        }
                        else if (x &gt; platformRight + 16)
                        {
                            yspeed = ySpeedAim(y, platformTop - (bbox_bottom - y) - 8, grav);
                            xspeed = xSpeedAim(x, y, platformRight - 4, platformTop - (bbox_bottom - y),
                                yspeed, grav);
                            imgIndex = 5;
                            counter = xspeed; // lol reusing to persist xspeed
                            image_xscale = -1;
                        }
                        else
                        {
                            // walk out from under the platform
                            phase = 2;
                            nextPhase = 0;
                            
                            if (x &lt; (platformRight + platformLeft) / 2)
                            {
                                walkX = platformLeft - 32;//17;
                                image_xscale = -1;
                            }
                            else
                            {
                                walkX = platformRight + 32;//17;
                                image_xscale = 1;
                            }
                        }
                    }
                }
                else
                {
                    imgIndex = 5;
                    xspeed = counter;
                }
                
                break;
            
            // wait, then decide next move
            case 1:
                timer++;
                if (timer &gt;= 32 || noDelay)
                {
                    timer = 0;
                
                    imgIndex = 0;
                    calibrateDirection();
                    
                    if (bbox_bottom &gt; platformTop)
                    {
                        // jump back onto our platform
                        phase = 0;
                        nextPhase = 0;
                    }
                    else if (instance_exists(target))
                    {
                        if (target.bbox_top &gt; platformTop &amp;&amp; canSpear)
                        {
                            // always shoot spears if player is in range for them
                            phase = 5;
                            imgIndex = 11;
                        }
                        else
                        {
                            // randomly choose next action
                            if (instance_exists(shield) || noDelay)
                            {
                                // don't create shield or shoot stream when shield exists
                                phase = choose(2, 3);
                            }
                            else
                            {
                                do
                                {
                                    phase = choose(2, 3, 4, 4, 6, 6);
                                }
                                until (ds_list_find_index(lastAttacks, phase) == -1)
                            }
                        }
                    }
                    else
                    {
                        // randomly choose next action
                        if (instance_exists(shield) || noDelay)
                        {
                            // don't create shield when shield already exists
                            phase = choose(2, 3);
                        }
                        else
                        {
                            do
                            {
                                phase = choose(2, 3, 4, 4);
                            }
                            until (ds_list_find_index(lastAttacks, phase) == -1)
                        }
                    }
                    
                    // set move destination
                    if (phase == 2 || phase == 3)
                    {
                        if (x &lt; (platformRight + platformLeft) / 2)
                        {
                            walkX = platformRight - 16;
                            image_xscale = 1;
                        }
                        else
                        {
                            walkX = platformLeft + 16;
                            image_xscale = -1;
                        }
                    }
                    
                    noDelay = false;
                    canSpear = true;
                    
                    // update last attacks list
                    if (phase != 5 &amp;&amp; phase != 0) // situational moves don't count for this
                    {
                        ds_list_add(lastAttacks, phase);
                        while (ds_list_size(lastAttacks) &gt; 2)
                        {
                            ds_list_delete(lastAttacks, 0);
                        }
                    }
                }
                
                break;
            
            // walk
            case 2:
                // animation
                if (!ground)
                {
                    imgIndex = 5;
                }
                else
                {
                    imgIndex += imgSpd;
                    if (imgIndex &lt; 6 || imgIndex &gt;= 10)
                    {
                        imgIndex = 6;
                    }
                }
                
                // jump over walls
                if (xcoll != 0 &amp;&amp; ground)
                {
                    yspeed = (jumpSpeed + jumpSpeedWater * (inWater &gt; 0)) * -gravDir;
                }
                
                // trigger end
                if ((image_xscale &gt; 0 &amp;&amp; x &gt;= walkX)
                    || (image_xscale &lt; 0 &amp;&amp; x &lt;= walkX))
                {
                    x = walkX;
                    xspeed = 0;
                    if (ground)
                    {
                        yspeed = 0;
                        phase = nextPhase;
                        imgIndex = 0;
                    }
                }
                else
                {
                    // moving
                    image_xscale = sign(walkX - x);
                    xspeed = walkSpeed * image_xscale;
                }
                
                break;
            
            // low jump
            case 3:
                // jumping
                if (ground)
                {
                    imgIndex = 4;
                    xspeed = 0;
                    
                    timer--;
                    if (timer &lt;= 0)
                    {
                        if (x &lt; walkX - 1 || x &gt; walkX + 1)
                        {
                            // jump
                            timer = 10;
                            
                            if (!counter) // lol reusing as a boolean
                            {
                                // low jump
                                yspeed = ySpeedAim(y, y - 32, grav);
                                
                                if (abs(round(x) - walkX) &lt;= 34)
                                {
                                    xspeed = xSpeedAim(x, y, walkX, y);
                                }
                                else
                                {
                                    xspeed = xSpeedAim(x, y, x + 32 * image_xscale, y);
                                }
                                
                                ground = false;
                                image_xscale = sign(walkX - x);
                            }
                            else
                            {
                                // high jump
                                yspeed = (jumpSpeed + jumpSpeedWater * (inWater &gt; 0)) * -gravDir;
                            }
                        }
                        else
                        {
                            // end
                            x = walkX;
                            xspeed = 0;
                            phase = nextPhase;
                            imgIndex = 0;
                        }
                    }
                }
                else
                {
                    imgIndex = 5;
                    
                    // ready high jump to get over obsticals
                    counter = xcoll != 0;
                }
                
                break;
            
            // create water shield
            case 4:
                // anim
                imgIndex = 4;
                
                // create shieid
                timer++;
                if (timer == 10)
                {
                    if (instance_exists(shield))
                    {
                        with (shield)
                        {
                            instance_destroy();
                        }
                    }
                    
                    shield = instance_create(x, y, objMegaWaterSShield);
                    shield.parent = id;
                }
                
                // end
                if (timer &gt;= 50)
                {
                    timer = 0;
                    imgIndex = 0;
                    phase = nextPhase;
                }
                
                break;
            
            // shoot spears
            case 5:
                // shoot
                if (timer == 0)
                {
                    var s = instance_create(x + 22 * image_xscale, y + 13 * image_yscale, objEnemyBullet);
                    s.sprite_index = sprMegaWaterSSpear;
                    s.image_xscale = image_xscale;
                    s.contactDamage = 2;
                    
                    var angle = 180 + 30 + 90 * (image_xscale &gt; 0);
                    if (instance_exists(target))
                    {
                        var a = point_direction(x, y,
                            bboxGetXCenterObject(target), bboxGetYCenterObject(target));
                        
                        // round to the nearest angle that's a multiple of 15
                        var b = a;
                        if (b mod 15 * 15 &gt; 15)
                        {
                            b = b div 15 * 15 + 15;
                        }
                        else
                        {
                            b = b div 15 * 15;
                        }
                        
                        // push out of invalid angles
                        if (b mod 30 == 0)
                        {
                            if (a &lt; b)
                            {
                                b -= 15;
                            }
                            else
                            {
                                b += 15;
                            }
                        }
                        
                        // restrict directions we can aim at
                        b = loopDegrees(b);
                        if (image_xscale &lt; 0)
                        {
                            if (withinDegreeRange(0, false, 180, true, b))
                            {
                                b = 180 + 15;
                            }
                            
                            if (withinDegreeRange(270, true, 360, true, b))
                            {
                                b = 270 - 15;
                            }
                        }
                        else
                        {
                            if (withinDegreeRange(0, true, 180, false, b))
                            {
                                b = 360 - 15;
                            }
                            
                            if (withinDegreeRange(180, true, 270, true, b))
                            {
                                b = 270 + 15;
                            }
                        }
                        
                        angle = b;
                    }
                    
                    s.xspeed = 4 * cos(degtorad(angle));
                    s.yspeed = 4 * -sin(degtorad(angle));
                    
                    // set sprite
                    if (angle == 180 || angle == 0 || angle == 360)
                    {
                        s.image_index = 0;
                    }
                    
                    if (angle == 180 + 15 || angle == 360 - 15)
                    {
                        s.image_index = 1;
                    }
                    
                    if (angle == 180 + 45 || angle == 360 - 45)
                    {
                        s.image_index = 2;
                    }
                    
                    if (angle == 270 - 15 || angle == 270 + 15)
                    {
                        s.image_index = 3;
                    }
                    
                    if (angle == 270)
                    {
                        s.image_index = 4;
                    }
                    
                    playSFX(sfxEnemyShootClassic);
                }
                
                timer++;
                if (timer &lt;= 10)
                {
                    imgIndex = 11;
                }
                else if (timer &lt;= 10 + 16)
                {
                    imgIndex = 4;
                }
                else
                {
                    phase = nextPhase;
                    noDelay = true;
                }
                
                break;
            
            // shoot stream
            case 6:
                timer++;
                if (timer mod floor(11 / 3) == 0)
                {
                    var w = instance_create(x + (27 + 4) * image_xscale, y - 3 * image_yscale,
                        objMegaWaterSStream);
                    w.image_xscale = image_xscale;
                    w.xspeed = w.xSpd * w.image_xscale;
                }
                
                if (!audio_is_playing(sfxTelTelRain))
                {
                    playSFX(sfxTelTelRain);
                }
                
                imgIndex = 10;
                
                if (timer &gt;= 200)
                {
                    phase = nextPhase;
                    noDelay = true;
                    canSpear = false;
                    stopSFX(sfxTelTelRain);
                }
                
                break;
        }
    }
}
else
{
    stopSFX(sfxTelTelRain);
}

image_index = imgIndex div 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="21">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// EV_GUARD atomic fire damage values
event_inherited();

if (other.object_index == objAtomicFire)
{
    switch (other.sprite_index)
    {
        case sprAtomicFire1:
            global.damage = 1; break;
        case sprAtomicFire2:
            global.damage = 3; break;
        case sprAtomicFire3:
            global.damage = 3; break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

with (objEnemyBullet)
{
    instance_destroy();
}

with (objMegaWaterSStream)
{
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
