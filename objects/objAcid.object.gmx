<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprAcid</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100</depth>
  <persistent>0</persistent>
  <parentName>objWater</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// water that can damage entities based on acidity level and being electrified
// toxic chemical based attacks from enemies and player increase acidity level
// water based attacks from enemies and player decrease acidity level
// when acidity level is maximum, this object will start dealing damage
// electricity based attacks will temporarily electrify the object, causing it to deal damage regardless

canDamage = 0;
faction = 0;
attackDelay = 0;
contactDamage = 3;
dead = 0;
pierces = 2;
penetrate = 3;
iFrames = 0;
killOverride = false;

//@cc: if you don't want either interaction, set the corresponding one to 0
enableAcidity = 1;
enableElectrifying = 1;

acidityLevel = 0;
acidityLevelPrevious = 0;
defaultAcidityLevel = 0;
maxAcidityLevel = 3;
acidityChangeDir = 0;

acidityChangeCooldown = 0;
acidityChangeCooldownMax = 10;

electrified = 0;
electrifiedAnimTimer = 0;

var index = 0;
acidic[index++] = objGloopBall;
acidic[index++] = objAcidDrop;
acidic[index++] = objOilStream;

index = 0;
acidicPersistent[index++] = objNitronFire;

index = 0;
cleansing[index++] = objFlowerPresenterFlower;
cleansing[index++] = objWaterWave;
cleansing[index++] = objWaterWaveProjectile;
cleansing[index++] = objWaterBalloon;

index = 0;
cleansingPersistent[index++] = objFeeberBubble;

index = 0;
electrifying[index++] = objBiree;
electrifying[index++] = objSparkShock;

index = 0;
hurts[index++] = prtEntity;

index = 0;
hurtsThroughCanHitFalse[index++] = noone;

acidColor[0] = c_blue;
acidColor[1] = c_yellow;
acidColor[2] = c_red;
acidColor[3] = c_green;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!global.frozen)
{
    if(enableAcidity &amp;&amp; acidityChangeCooldown &lt;= 0) // can change acidity
    {
        acidityLevelPrevious = acidityLevel;
        if(acidityLevel &lt; maxAcidityLevel) // can be acidized
        {
            for(var i = 0; i &lt; array_length_1d(acidic); i++)
            {
                with(acidic[i])
                {
                    if(place_meeting(x,y,other))
                    {
                        instance_destroy();
                        with(other)
                        {
                            acidityChangeDir = 1;
                            event_user(0);
                        }
                        i = array_length_1d(other.acidic);
                    }
                }
            }
            for(var i = 0; i &lt; array_length_1d(acidicPersistent); i++)
            {
                with(acidicPersistent[i])
                {
                    if(place_meeting(x,y,other))
                    {
                        with(other)
                        {
                            acidityChangeDir = 1;
                            event_user(0);
                        }
                        i = array_length_1d(other.acidicPersistent);
                    }
                }
            }
        }
        if(acidityLevel &gt; 0) // can be cleansed
        {
            for(var i = 0; i &lt; array_length_1d(cleansing); i++)
            {
                with(cleansing[i])
                {
                    if(place_meeting(x,y,other))
                    {
                        instance_destroy();
                        with(other)
                        {
                            acidityChangeDir = -1;
                            event_user(0);
                        }
                        i = array_length_1d(other.cleansing);
                    }
                }
            }
            for(var i = 0; i &lt; array_length_1d(cleansingPersistent); i++)
            {
                with(cleansingPersistent[i])
                {
                    if(place_meeting(x,y,other))
                    {
                        with(other)
                        {
                            acidityChangeDir = -1;
                            event_user(0);
                        }
                        i = array_length_1d(other.cleansingPersistent);
                    }
                }
            }
        }
    }
    else acidityChangeCooldown--;
    
    electrified = 0;
    if(enableElectrifying)
    {
        for(var i = 0; i &lt; array_length_1d(electrifying); i++)
        {
            with(electrifying[i])
            {
                if(place_meeting(x,y,other))
                {
                    other.electrified = 1;
                    i = array_length_1d(other.electrifying);
                }
            }
        }
        
        if(electrified) electrifiedAnimTimer++;
        else electrifiedAnimTimer = 0;
    }
    
    var canDoDamage = (acidityLevel == maxAcidityLevel || electrified);
    if(canDoDamage)
    {
        for(var i = 0; i &lt; array_length_1d(hurts); i++)
        {
            with(hurts[i]) if(canHit)
            {
                if(place_meeting(x,y,other) &amp;&amp; instance_exists(self))
                {
                    if(iFrames == 0) with(other) entityEntityCollision(contactDamage);
                }
            }
        }
        
        for(var i = 0; i &lt; array_length_1d(hurts); i++)
        {
            with(hurtsThroughCanHitFalse[i])
            {
                if(place_meeting(x,y,other) &amp;&amp; instance_exists(self))
                {
                    if(iFrames == 0) with(other) entityEntityCollision(contactDamage);
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// change acidity
acidityLevel += acidityChangeDir;
acidityChangeDir = 0;
if(acidityLevel &lt; 0) acidityLevel = 0;
else if(acidityLevel &gt; maxAcidityLevel) acidityLevel = maxAcidityLevel;
acidityChangeCooldown = acidityChangeCooldownMax;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>acidityLevel = defaultAcidityLevel;
acidityLevelPrevious = defaultAcidityLevel;

image_xscale = abs(image_xscale);
image_yscale = abs(image_yscale);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for(var i = 0; i &lt; image_xscale; i++) for(var j = 0; j &lt; image_yscale; j++)
{
    var currentColor = acidColor[acidityLevel];
    if(acidityChangeCooldown &gt; 0)
    {
        var curColR = colour_get_red(acidColor[acidityLevelPrevious]) + abs(colour_get_red(acidColor[acidityLevelPrevious])-colour_get_red(acidColor[acidityLevel]))*((acidityChangeCooldownMax-acidityChangeCooldown)/acidityChangeCooldownMax),
            curColG = colour_get_green(acidColor[acidityLevelPrevious]) + abs(colour_get_green(acidColor[acidityLevelPrevious])-colour_get_green(acidColor[acidityLevel]))*((acidityChangeCooldownMax-acidityChangeCooldown)/acidityChangeCooldownMax),
            curColB = colour_get_blue(acidColor[acidityLevelPrevious]) + abs(colour_get_blue(acidColor[acidityLevelPrevious])-colour_get_blue(acidColor[acidityLevel]))*((acidityChangeCooldownMax-acidityChangeCooldown)/acidityChangeCooldownMax);
        currentColor = make_color_rgb(curColR,curColG,curColB);
    }
    if(j == 0) draw_sprite_part_ext(sprite_index,0,0,0,16,16,x+i*16,y+j*16,1,1,currentColor,1);
    else draw_sprite_part_ext(sprite_index,1,0,0,16,16,x+i*16,y+j*16,1,1,currentColor,1);
    
    if(electrified)
    {
        var elecSprImg = 3;
        if((electrifiedAnimTimer mod 6) &lt; 3) elecSprImg = 2;
        draw_sprite(sprite_index,elecSprImg,x+i*16,y+j*16);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
