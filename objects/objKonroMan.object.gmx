<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprKonroStand</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtBoss</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// konro man 1.1 jul 13 2020 - deletes arrays on death and added fireball remnant damage, improved comments

healthpointsStart = 28;
healthpoints = healthpointsStart;
pose = sprKonroStand;
poseImgSpeed = 6 / 60;
ground = false;
grav = 0.25

//Damage settings.
contactDamage = 4;
flamesDamage = 2
fireballWallDamage = 2
fireballRemnantDamage = 2
hoverFireballDamage = 1

wallStandDistance = 36 // How far away from the edges of the screen should Konro stop/land? if there's a wall he'll try and stop automatically though
totalFlames = 5 ;// total flames to make including edge flames
flameCollisionHeight = (view_yview + (view_hview/2)) // turn off flame collision above a y. for if you want to use it with ceilings
leftFlameX = view_xview + 24; // this will be the default when its on the far side of the room, but its +20 when konro's there to be next to him
rightFlameX = (view_xview+view_wview) - 24;  // vice versa left flame, -20 when konro's there to sit next to him
flameDropSpeed = 1.5 // this is 1 in the orig but the screen's bigger here
totalWallFireballs = 3 
fireballWallGroundHeight = 12 // distance from floor first fireball is at
fireballWallSpacing = 8 // vertical separation beteeen each fireball
fireballWallSpeed = 1.5 // note this can have weird effects on where the remnants get left
fireballRemnantDistance = 56 //distance at which fireballs leave static fireballs
crossRoomHeight = 21 // how many pixels below the top of the screen does konro man stop rising at (he will also try to stop at ceilings)
konroHoverSpeed = 1.25 
totalHoverFireballs = 5 
hoverFireballLargestAngle = 45 // the angle difference from straight down the farthest fireballs aim at
hoverFireballWaitTime = 50 // how many frames wait top middle

//utilized stuff for konro's ai
phase = 0; 
phaseTimer = 0;
//konro's phases are mirrored, 0-4 is right side screen, 5-9 is left side. sorry.
//0/5: fire flames up off screen
//1/6: drop flames from the ceiling
//2/7: generate fireball wall
//3/8: start hovering, fire fireballs
//4/9: end hovering, switch to next phase

upFlameCount = 0 ;//used to count fired flames
upFlamePos = 0 ;// used to set where firing from
flameRange = 0; //automatically generated from flame Xs
flameLandingTime = 0; // set in code from other stuff
waitingForFlamesLand = false; // phase thing after dropping flames
remnantDistanceChecker = 0;
remnantDistanceTimes = 0;
crossingRoom = false; //track when high enough
firedHoverFireballs = false;
var i
for (i = (totalFlames-1); i &gt; -1; i --) // initialize backwards for memory rsns
{
    flameTracker[i] = noone;// - used to place flames. 
}
for (i = totalWallFireballs-1; i &gt; -1; i --)
{
    fireballWallTracker[i] = noone;//used to track wall parts
}
for (i = totalHoverFireballs-1; i&gt; -1 ; i --)
{
    hoverFireballTracker[i] = noone;
}
    
// health bar variables
healthBarPrimaryColor[1] = 19;
healthBarSecondaryColor[1] = 40;

// Music
music = "RnFBossNES.ogg";
musicType = "OGG";
musicLoopSecondsStart = 55.70;
musicLoopSecondsEnd = 79.70;
musicVolume = 0.8;

// Damage Table
enemyDamageValue(objBusterShot, 1);
enemyDamageValue(objBusterShotHalfCharged, 1);
enemyDamageValue(objBusterShotCharged, 3);

// MM1
enemyDamageValue(objSuperArmBlockProjectile, 2);
enemyDamageValue(objSuperArmDebris, 2);
enemyDamageValue(objIceSlasher, 0);
enemyDamageValue(objThunderBeam, 1);

// MM2
enemyDamageValue(objMetalBlade, 1);

// MM3
enemyDamageValue(objNeedleCannon, 0);
enemyDamageValue(objMagnetMissile, 2);
enemyDamageValue(objGeminiLaser, 2);
enemyDamageValue(objHardKnuckle, 0);
enemyDamageValue(objTopSpin, 4);
enemyDamageValue(objSearchSnake, 1);
enemyDamageValue(objSparkShock, 1);
enemyDamageValue(objShadowBlade, 1);

// MM4
enemyDamageValue(objRainFlush, 4);
enemyDamageValue(objPharaohShot, 0);

// MM5
enemyDamageValue(objPowerStone, 2);

// MM6
enemyDamageValue(objPlantBarrier, 0);

// MM7
enemyDamageValue(objSlashClaw, 1);

// MM8
enemyDamageValue(objHomingSniper, 1);

// MM9
enemyDamageValue(objConcreteShot, 2);
enemyDamageValue(objTornadoBlow, 4);
enemyDamageValue(objLaserTrident, 1);
enemyDamageValue(objJewelSatellite, 0);
enemyDamageValue(objHornetChaser, 0);
enemyDamageValue(objBlackHoleBomb, 2);

// MM10
enemyDamageValue(objTripleBlade, 1);
enemyDamageValue(objWaterShield, 4);
enemyDamageValue(objChillShot, 0);
enemyDamageValue(objChillSpikeLanded, 0);
enemyDamageValue(objThunderWool, 2);
enemyDamageValue(objWheelCutter, 1);
enemyDamageValue(objSolarBlaze, 0);

// MM11
enemyDamageValue(objBlockDropper, 2);

// MMI

// MMII
enemyDamageValue(objSakugarne, 2);

// MMIII

// MMIV

// MMV
enemyDamageValue(objSparkChaser, 1);
enemyDamageValue(objGrabBuster, 2);
enemyDamageValue(objBreakDash, 1);
enemyDamageValue(objSaltWater, 4);

// MM&amp;B
enemyDamageValue(objTenguBlade, 2);
enemyDamageValue(objTenguDash, 2);
enemyDamageValue(objTenguDisk, 2);
enemyDamageValue(objIceWall, 1);
enemyDamageValue(objMagicCard, 2);

// MM&amp;B2
enemyDamageValue(objFlameMixer, 0);

// Other
enemyDamageValue(objMagneticShockwave, 1);

// Utilities
enemyDamageValue(objWireAdapter, 4);
enemyDamageValue(objSuperArrow, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

/// ok so i'ma give you a quick word of warning
// if i was a GOOD programmer i'd have made one set of code that he reads through and does on both sides of the screen
// but im NOT a good programmer
// so INSTEAD here's how i do it. each side of the room is hard coded.
// phases 0-4 are him starting on the right and moving to the left.
// phaes 5-9, in turn, are him starting on the left
// so if you want to change something in the code here, make sure to do it for both sides! unless you wanna vary it up. that could be cool
// but regardless, be aware of that

if (entityCanStep())
{
    if (isIntro == true)
    { // initialize which side of the room to start on based on placement
        if (x &lt;= view_xview + (view_wview/2))  // i'm on the left half of room!
        {
            phase = 5; // left side phase!
            x = view_xview + wallStandDistance; // automatically appear at my wallStandDistance!
        }
        else // right half of room
        {
            phase = 0 // right side phase!
            x = (view_xview + view_wview) - wallStandDistance; // same!
        }
        calibrateDirection();
    }
    if (isFight == true)
    {
        switch (phase)
        {
            case 0: // fire flames up
            {
                phaseTimer ++;
                if phaseTimer == 1
                {
                    calibrateDirection(); // i should already do this in intro but just to be safe
                    sprite_index = sprKonroStand;
                    image_index = 0;
                }
                if phaseTimer == 24 // yes Konro changes to this sprite 1 frame before firing in the original. idk why either
                {
                    image_index = 1;
                }
                if (phaseTimer &gt; 24) &amp;&amp; ((phaseTimer - 25) mod 10 = 0) &amp;&amp; (upFlameCount &lt; totalFlames) // frame 25 and every 10 after if not all fired
                { // generate flames and store them in the tracker array. 
                    flameTracker[upFlameCount] = instance_create(x-8+(upFlamePos*8),y-16,objKonroFlame)
                    with flameTracker[upFlameCount]
                    {
                        collisionOffHeight = other.flameCollisionHeight;
                        contactDamage = other.flamesDamage;
                        image_yscale = -1; // they're going up so upside down
                        xspeed = 0;
                        yspeed = -2; // i didnt make fireball up speed customizable but obviously you can make it faster if you want here
                    }
                    upFlameCount ++
                    upFlamePos ++
                    if upFlamePos &gt; 2 // once you've fired 3, reset the horizontal position
                    {
                        upFlamePos = 0 
                    }
                    playSFX(sfxSolarBlazeSmall) // fwoosh
                }
                if phaseTimer == 44 // change to image 2 1 frame before firing third flame
                {
                    image_index = 2;
                }
                if (phaseTimer = (totalFlames - 1)) &amp;&amp; ((phaseTimer - 25) mod 10 = 1) // change to THIS one frame before ending
                {
                    image_index = 1;
                }
                if upFlameCount &gt;= (totalFlames) // once you've fired every flame
                {
                    flameTracker[totalFlames-1].x = x+8 // always move the last one to the farthest right position
                    upFlameCount = 0;
                    upFlamePos = 0;
                    image_index = 0;
                    phase = 1; 
                    phaseTimer = 0;
                }
                break;
            }
            case 1: // bring flames down from the ceiling
            {
                image_index = 0 // chill out for a while
                    phaseTimer ++
                if (phaseTimer == 125) // i just hardcoded this because i don't think it matters that much.
                {
                    flameRange = (rightFlameX - 28) - leftFlameX; // this sets up the length of the distance to divide flame drop x over
                    for (i = 0; i &lt; totalFlames; i++) // do this for each flame you have
                    {
                        if instance_exists(flameTracker[i]) // if you didnt have this it'd crash should one be killed or lost
                        {
                            flameTracker[i].x = view_xview + leftFlameX + (flameRange * (i/(totalFlames - 1))); // (i/totalFlames-1) sets them to the upper number of a fraction: one should be 1/Xths of the way, another 2/Xths, 3/Xths, etc
                            if (i mod 2 = 1) // even fireballs are higher than odd fireballs
                            {
                                flameTracker[i].y = view_yview - 32 - (i*10)
                            }
                            else
                            {
                                flameTracker[i].y = view_yview - (i*10)
                            }
                            flameTracker[i].yspeed = flameDropSpeed; 
                            flameTracker[i].image_yscale = 1; //now they're dropping, so set them to have the trailing side up
                        }
                        flameLandingTime = (((y + 20) - (view_yview - (i * 10))) / flameDropSpeed) // this is almost accurate but not quite. idk
                        waitingForFlamesLand = true;
                    }
                }
                if (phaseTimer &gt;= 125 + flameLandingTime) &amp;&amp; (waitingForFlamesLand == true) // so this has to be here since you can customize the
                { // number of fireballs, and more fireballs take longer to fall down
                    waitingForFlamesLand = false;
                    phaseTimer = 0
                    phase = 2
                }
                break;
            }
            case 2: // generate firebal wall
            {
                phaseTimer ++;
                if phaseTimer == 1
                {
                    sprite_index = sprKonroLean
                    image_index = 0
                }
                if phaseTimer == 25
                {
                    image_index = 1
                    for (i = 0; i &lt; totalWallFireballs; i ++) // here we make another array since konro has to talk to the fireballs a lot
                    {
                        fireballWallTracker[i] = instance_create(x-24,(y+20)-fireballWallGroundHeight-(i*fireballWallSpacing),objKonroFireball)
                        with (fireballWallTracker[i])
                        {
                            fireballRemnantDamage = other.fireballRemnantDamage
                            fireballRemnantDistance = other.fireballRemnantDistance 
                            fireballWallOrigin = x; // set where it came from for distance reasons so it can tell when it's fully rebounded
                            xspeed = -other.fireballWallSpeed;
                            contactDamage = other.fireballWallDamage;
                            remnantDistanceTimes = 1;  // this could be 0 but then i'd have to tell it not to make a remnant when it first spawns
                        }
                    }
                    playSFX(sfxSolarBlazePopLarge)
                }
                if phaseTimer &gt; 25
                {
                    for (i = totalWallFireballs-1; i &gt; -1; i --) // loop through each wallfireball every frame (yes im sorry)
                    {
                        if instance_exists(fireballWallTracker[i])
                        {
                            with (fireballWallTracker[i]) // WITH each wallfireball
                            {
                                remnantDistanceChecker = (fireballWallOrigin - x) // keep track of how far ive traveled
                                if (remnantDistanceChecker &gt; (fireballRemnantDistance*remnantDistanceTimes)) &amp;&amp; (rebounding = false)
                                { // this basically makes sure it knows to make a fireball even if it "overshoots" its creation distance
                                    remnant = instance_create(x,y,objKonroFireballRemnant)
                                    if instance_exists(remnant)
                                    {
                                        remnant.contactDamage = fireballRemnantDamage
                                    }
                                    remnantDistanceTimes ++
                                }
                                if (((checkSolid(x-16,0)) = true) || x &lt; view_xview + 16) &amp;&amp; (rebounding = false) // either bounce off wall or go back on own
                                {
                                    rebounding = true // this is used to turn on collect fireballs mode
                                    xspeed *= -1
                                }
                                if (rebounding = true) &amp;&amp; (place_meeting(x,y,objKonroFireballRemnant)) //idk if i should use instance_place here too
                                {
                                    destroyingThisRemnant = (instance_place(x,y,objKonroFireballRemnant)) // u need it here to set the target tho
                                    with (destroyingThisRemnant)
                                    {
                                        instance_destroy() // get outta here
                                    }
                                }
                                if (rebounding = true) &amp;&amp; (x &gt; fireballWallOrigin)
                                {
                                    instance_destroy()
                                }
                            }
                        }
                        else
                        {
                            continue;
                        }
                    }
                    if (!instance_exists(objKonroFireball)) or (phaseTimer &gt;= 500) // this is my failsafe to make sure nothing bad goes wrong
                    {
                        with (prtEnemyProjectile) // destroy all projectiles and make explosions
                        {
                            instance_create(x,y,objExplosion) // looks nicer than in the orig where they just vanish
                            instance_destroy()
                        }
                    image_index = 0
                    phase = 3
                    phaseTimer = 0
                    }
                }
                break;
            }
            case 3: // start hovering and create freballs
            {
                phaseTimer ++
                if phaseTimer == 50 // chill out before hovering, gives you some time to hit it
                {
                    grav = 0;
                    sprite_index = sprKonroHover; // weee
                    yspeed = -konroHoverSpeed
                }
                if (phaseTimer &gt; 50) &amp;&amp; ((y &lt; view_yview + crossRoomHeight) or (checkSolid(0,-1))) &amp;&amp; (crossingRoom = false)
                { //when you get high enough or hit a ceiling and haven't started crossing the room yet
                    crossingRoom = true;
                    xspeed = -konroHoverSpeed;
                    yspeed = 0
                }
                if (crossingRoom = true) &amp;&amp; (x &lt; (view_xview + (view_wview / 2))) // when you pass the center from the right
                    {
                        x = (view_xview + (view_wview / 2)) // make sure you're in the center
                        xspeed = 0 // stop
                        image_index = 1
                        hoverFireballSwath = 2*hoverFireballLargestAngle // this is like the fireball range earlier, but both sides are evenly distanced
                        for (i = totalHoverFireballs - 1; i &gt; -1; i --)
                        {
                            hoverFireballTracker[i] = instance_create(x,y+24,objKonroFireballDestroyable) // same math as with the flames, set it by the farthest. 270 is straight down
                            hoverFireballTracker[i].xspeed = cos(degtorad((270 - hoverFireballLargestAngle) + hoverFireballSwath * (i/(totalHoverFireballs - 1))))
                            hoverFireballTracker[i].yspeed = -sin(degtorad((270 - hoverFireballLargestAngle) + hoverFireballSwath * (i/(totalHoverFireballs - 1))))
                            hoverFireballTracker[i].contactDamage = hoverFireballDamage
                        }
                        playSFX(sfxSolarBlazeLarge)
                        phase = 4
                        phaseTimer = 0;
                    }
                break;
            }
            case 4: // finish crossing the room
            {
                phaseTimer ++
                if phaseTimer == hoverFireballWaitTime
                {
                    xspeed = -konroHoverSpeed
                }
                if (phaseTimer &gt;= hoverFireballWaitTime) &amp;&amp; ((checkSolid(-1,0) = true) or (x &lt;= view_xview + wallStandDistance))
                { // when you smack into a wall or get far enough to the left
                    xspeed = 0
                    yspeed = konroHoverSpeed //let's float on down
                    crossingRoom = false;
                }
                if (crossingRoom = false) &amp;&amp; (checkSolid(0,1))
                {
                    x += 1 // trying to get out of walls since that was a problem with earlier versions
                    grav = 0.25
                    yspeed = 0
                    phase = 5 // switch to other side of the room coooode
                    phaseTimer = 0
                }
                break;
            }
            //////
            //////
            //////LEFT SIDE OF ROOM RIGHT SIDE OF ROOM BOUNDARY HERE
            //////ON LEFT SIDE STARTS AT CASE 5
            ////// i haven't commented as extensively here. everything should match up with the previous segment but reversed
            //////
            case 5:
            {
                phaseTimer ++;
                if phaseTimer == 1
                {
                    calibrateDirection();
                    sprite_index = sprKonroStand;
                    image_index = 0;
                }
                if phaseTimer == 24
                {
                    image_index = 1;
                }
                if (phaseTimer &gt; 24) &amp;&amp; ((phaseTimer - 25) mod 10 = 0) &amp;&amp; (upFlameCount &lt; totalFlames) // frame 25 and every 10 after if not all fired
                {
                    flameTracker[upFlameCount] = instance_create(x-8+(upFlamePos*8),y-16,objKonroFlame)
                    with flameTracker[upFlameCount]
                    {
                        collisionOffHeight = other.flameCollisionHeight;
                        image_yscale = -1;
                        xspeed = 0;
                        yspeed = -2;
                        contactDamage = other.flamesDamage;
                    }
                    upFlameCount ++
                    upFlamePos ++
                    if upFlamePos &gt; 2
                    {
                        upFlamePos = 0
                    }
                    playSFX(sfxSolarBlazeSmall)
                }
                if phaseTimer == 44 // change to image 2 1 frame before firing third flame
                {
                    image_index = 2;
                }
                if (phaseTimer = (totalFlames - 1)) &amp;&amp; ((phaseTimer - 25) mod 10 = 1)
                {
                    image_index = 1;
                }
                if upFlameCount &gt;= (totalFlames)
                {
                    flameTracker[totalFlames-1].x = x+8 
                    upFlameCount = 0;
                    upFlamePos = 0;
                    image_index = 0;
                    phase = 6;
                    phaseTimer = 0;
                }
                break;
            }
            case 6:
            {
                image_index = 0
                    phaseTimer ++
                if (phaseTimer == 125)
                {
                    flameRange = rightFlameX - (leftFlameX + 28); 
                    for (i = 0; i &lt; totalFlames; i++)
                    {
                        if instance_exists(flameTracker[i]) //ok so here we have to flip the math and actually flip the distances across the room's width
                        { // thus we add view_xview + view_wview to get room edge, then subtract the difference between the flame xs and the room x
                            flameTracker[i].x = (view_xview + view_wview) - (leftFlameX + (flameRange * (i/(totalFlames - 1)))); 
                            if (i mod 2 = 1)
                            {
                                flameTracker[i].y = view_yview - 32 - (i*10)
                            }
                            else
                            {
                                flameTracker[i].y = view_yview - (i*10)
                            }
                            flameTracker[i].yspeed = flameDropSpeed; 
                            flameTracker[i].image_yscale = 1;
                        }
                        flameLandingTime = (((y + 20) - (view_yview - (i * 10))) / flameDropSpeed) // this is almost accurate but not quite
                        waitingForFlamesLand = true;
                    }
                }
                if (phaseTimer &gt;= 125 + flameLandingTime) &amp;&amp; (waitingForFlamesLand == true)
                {
                    waitingForFlamesLand = false;
                    phaseTimer = 0
                    phase = 7
                }
                break;
            }
            case 7:
            {
                phaseTimer ++;
                if phaseTimer == 1
                {
                    sprite_index = sprKonroLean
                    image_index = 0
                }
                if phaseTimer == 25
                {
                    image_index = 1
                    for (i = 0; i &lt; totalWallFireballs; i ++)
                    { // generating to my right this time
                        fireballWallTracker[i] = instance_create(x+24,(y+20)-fireballWallGroundHeight-(i*fireballWallSpacing),objKonroFireball)
                        with (fireballWallTracker[i])
                        {
                            fireballRemnantDamage = other.fireballRemnantDamage
                            fireballRemnantDistance = other.fireballRemnantDistance // im copying this over cuz i feel like it should save cpu or someth
                            fireballWallOrigin = x; // set where it came from for distance reasons
                            xspeed = other.fireballWallSpeed; // going the other way this time
                            contactDamage = other.fireballWallDamage;
                            remnantDistanceTimes = 1;
                        }
                    }
                    playSFX(sfxSolarBlazePopLarge)
                }
                if phaseTimer &gt; 25
                {
                    for (i = totalWallFireballs-1; i &gt; -1; i --)
                    {
                        if instance_exists(fireballWallTracker[i])
                        {
                            with (fireballWallTracker[i])
                            {
                                remnantDistanceChecker = (x - fireballWallOrigin)
                                if (remnantDistanceChecker &gt; (fireballRemnantDistance*remnantDistanceTimes)) &amp;&amp; (rebounding = false)
                                {
                                    remnant = instance_create(x,y,objKonroFireballRemnant)
                                    if instance_exists(remnant)
                                    {
                                        remnant.contactDamage = fireballRemnantDamage
                                    }
                                    remnantDistanceTimes ++
                                }
                                if (((checkSolid(x+16,0)) = true) || (x &gt; (view_xview + view_wview) - 12)) &amp;&amp; (rebounding = false) // checking the other side this time
                                {
                                    rebounding = true
                                    xspeed *= -1
                                }
                                if (rebounding = true) &amp;&amp; (place_meeting(x,y,objKonroFireballRemnant))
                                {
                                    destroyingThisRemnant = (instance_place(x,y,objKonroFireballRemnant))
                                    with (destroyingThisRemnant)
                                    {
                                        instance_destroy()
                                    }
                                }
                                if (rebounding = true) &amp;&amp; (x &lt; fireballWallOrigin) // should be where it comes from
                                {
                                    instance_destroy()
                                }
                            }
                        }
                        else
                        {
                            continue;
                        }
                    }
                    if !instance_exists(objKonroFireball) or (phaseTimer &gt;= 500) // this is my failsafe to make sure nothing bad goes wrong
                    {
                        with (objKonroFlame)
                        {
                            instance_create(x,y,objExplosion) // not accurate but looks nicer than in the orig
                            instance_destroy()
                        }
                    image_index = 0
                    phase = 8
                    phaseTimer = 0
                    }
                }
                break;
            }
            case 8:
            {
                phaseTimer ++
                if phaseTimer == 50
                {
                    grav = 0;
                    sprite_index = sprKonroHover;
                    yspeed = -konroHoverSpeed
                }
                if (phaseTimer &gt; 50) &amp;&amp; ((y &lt; view_yview + crossRoomHeight) or (checkSolid(0,-1))) &amp;&amp; (crossingRoom = false)
                {
                    crossingRoom = true;
                    xspeed = konroHoverSpeed; // going the other way
                    yspeed = 0
                }
                if (crossingRoom = true) &amp;&amp; (x &gt; (view_xview + (view_wview / 2))) //checking the other way
                    {
                        x = (view_xview + (view_wview / 2))
                        xspeed = 0
                        image_index = 1
                        hoverFireballSwath = 2*hoverFireballLargestAngle
                        for (i = totalHoverFireballs - 1; i &gt; -1; i --)
                        {
                            hoverFireballTracker[i] = instance_create(x,y+24,objKonroFireballDestroyable) // same math as with the flames, set it by the farthest. 270 is straight down
                            hoverFireballTracker[i].xspeed = cos(degtorad((270 - hoverFireballLargestAngle) + hoverFireballSwath * (i/(totalHoverFireballs - 1))))
                            hoverFireballTracker[i].yspeed = -sin(degtorad((270 - hoverFireballLargestAngle) + hoverFireballSwath * (i/(totalHoverFireballs - 1))))
                            hoverFireballTracker[i].contactDamage = hoverFireballDamage
                        }
                        phase = 9
                        phaseTimer = 0;
                        playSFX(sfxSolarBlazeLarge)
                    }
                break;
            }
            case 9:
            {
                phaseTimer ++
                if phaseTimer == hoverFireballWaitTime
                {
                    xspeed = konroHoverSpeed //going other way
                }
                if (phaseTimer &gt;= hoverFireballWaitTime) &amp;&amp; ((checkSolid(1,0) = true) or (x &gt;= (view_xview + view_wview) - wallStandDistance)) // check other way
                {
                    xspeed = 0
                    yspeed = konroHoverSpeed
                    crossingRoom = false;
                }
                if (crossingRoom = false) &amp; (checkSolid(0,1))
                {
                    x -= 1
                    grav = 0.25
                    yspeed = 0
                    phase = 0 //please work
                    phaseTimer = 0
                }
                break;
            }
            default: // should never ever happen but just in case
            {
                phase = 0
                phaseTimer = 0
                break;
            }
            if phaseTimer &gt;= 2000 // this is a failsafe to reset it if something gets lost
            {
                phase = 0;
                phaseTimer = 0;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="21">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (sprite_index == sprKonroStand)
{
        other.guardCancel = 1
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// you should delete all your arrays after you're done with them to avoid
// a memory leak. like so
flameTracker = 0;
flameWallTracker = 0;
hoverFireballTracker = 0;

with (prtEnemyProjectile) // destroy all projectiles on death
{
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="18">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
