<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPhysicsBlock</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// multi-purpose block that can get pushed, float on water, fly, slide, etc.
// it's unfinished? I wanted to add more stuff to it but I forgot what
event_inherited();

healthpointsStart = 256;
healthpoins = healthpointsStart;
canHit = false;
canDamage = false;
isSolid = 1;
blockCollision = 1;
bubbleTimer = -1;
grav = 0.25;

splashTimerMax = 240;

despawnRange = -1;

prevxs = xspeed;
prevys = yspeed;

// @cc: how quick the block can slide down or up slopes (disabled by default)
slideOffSlopesFactor = 0;

// @cc: when grav is set to 0, used to gradually slow down to 0 vertical speed
stockGrav = grav;

// @cc: if true, block will emerge out of and float on water
buoyancy = true;
// @cc: how quick the block raises in water (this value has to be really really low)
density = 1/(32);
// @cc: how much extra weight will passengers apply to the block
carryWeightMult = 8;
// @cc: how much the block slows down in water when moving horizontally
horizDecel = 0.1;
// @cc: fastest possible speed the block will swim up with
maxForce = 4;

// @cc: how much the block slows down horizontally when moving on the ground
pushDecelGround = 0.15;
// @cc: how much the block slows down horizontally when moving in the air
pushDecelAir = 0.15;

// @cc: when touching walls, the block can rebound with speed multiplied by this value
reboundFactorX = 0;

// @cc: when touching floors or ceilings, the block can rebound with speed multiplied by this value
reboundFactorY = 0;

// @cc: which type of lava physics this block has
lavaPhysics = 2;
// 2 - floats on lava
// 1 - sinks in lava
// 0 - ignores lava

lavaSinkSpd = 0.2;

inLava = -1;

// @cc: when true, attacking the block pushes it
pushable = true;
// @cc: array of objects that can push the block, and another with the strength the
//  corresponding object pushes the block
var index = 0;
pushObject[index] = objBusterShot;
pushForce[index++] = 2;
pushObject[index] = objBusterShotHalfCharged;
pushForce[index++] = 2.5;
pushObject[index] = objBusterShotCharged;
pushForce[index++] = 3;

// ice block preset (slides down slopes, low ground deceleration)
// slideOffSlopesFactor = 0.25;
// pushDecelGround = 0.025;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if(entityCanStep())
{
    // if(!place_meeting(x,y,objWater)) inWater = false;
    
    // float on water
    if(buoyancy &amp;&amp; grav != 0)
    {
        var height = 0;
        if(inWater)
        {
            if(xspeed != 0 &amp;&amp; horizDecel != 0)
            {
                if(abs(xspeed) &lt; horizDecel) xspeed = 0;
                else xspeed -= sign(xspeed)*horizDecel;
            }
            
            var myWater = instance_place(x,y,objWater);
            if(myWater != noone)
            {
                if(grav &gt; 0)
                {
                    height = clamp(bbox_bottom-myWater.bbox_top,0,abs(bbox_top-bbox_bottom));
                }
                else if(grav &lt; 0)
                {
                    height = clamp(bbox_top-myWater.bbox_bottom,0,abs(bbox_top-bbox_bottom));
                }
            }
            
            var cargo = 0;
            with(prtEntity) if(!dead &amp;&amp; blockCollision &amp;&amp; place_meeting(x,y+sign(grav),other))
            {
                cargo += grav*other.carryWeightMult*other.density;
            }
            
            var force = height*density*grav - cargo;
            yspeed -= force;
            if(abs(yspeed) &gt; maxForce &amp;&amp; maxForce &gt; 0) yspeed = maxForce*sign(force);
        
            if((height &lt; abs(bbox_top-bbox_bottom)/2) &amp;&amp; (sign(yspeed) == -sign(grav)))
            {
                yspeed += grav;
            }
        }
    }
    
    if(grav == 0)
    {
        var desiredSpeed = 0;
        if(buoyancy &amp;&amp; inWater)
        {
            desiredSpeed = -abs(maxForce)*sign(stockGrav);
        }
        if(abs(desiredSpeed-yspeed) &lt; stockGrav) yspeed = desiredSpeed;
        else yspeed += sign(desiredSpeed-yspeed)*stockGrav;
    }
    
    // when hit, apply push to the block
    canHit = pushable;
    if(pushable)
    {
        for(var i = 0; i &lt; array_length_1d(pushObject); i++)
        {
            with(pushObject[i]) if(!dead &amp;&amp; place_meeting(x,y,other) &amp;&amp; !global.factionStance[self.faction, other.faction])
            {
                with(other)
                {
                    event_user(EV_REFLECTED);
                    event_user(EV_HURT);
                }
            }
        }
    }
    
    // lava physics
    if(inLava)
    {
        var removeLavaStatus = 1;
        with(objLava) if(!dead) with(other)
        {
            if(place_meeting(x,y,other))
            {
                var stop = 0;
                var combinedMoveSpd = 0;
                removeLavaStatus = 0;
                if(place_meeting(x,y,other))
                {
                    if(other.iceTimer &gt; 0) stop = 1;
                    else combinedMoveSpd += other.flowSpd;
                }
                if(stop)
                {
                    xspeed = 0;
                    yspeed = -grav;
                    removeLavaStatus = 0;
                }
                else switch(lavaPhysics)
                {
                    case 2: // float
                        var midTouchLava = noone;
                        with(objLava) if(!dead) with(other)
                        {
                            if(place_meeting(x,y-sign(grav)*0.5*sprite_height,other))
                            {
                                midTouchLava = other;
                            }
                        }
                        if(midTouchLava)
                        {
                            if(abs(yspeed) &gt; abs(maxForce)) yspeed = sign(yspeed)*abs(maxForce);
                            yspeed -= floor(abs(yspeed)+2)*grav;
                        }
                        else
                        {
                            if(place_meeting(x,y-sign(grav)*0.5*sprite_height+sign(grav),other) &amp;&amp; !midTouchLava)
                            {
                                yspeed = -grav;
                            }
                            else yspeed += -grav+sign(grav)*lavaSinkSpd;
                        }
                        shiftObject(combinedMoveSpd*sign(grav),0,blockCollision);
                        removeLavaStatus = 0;
                        break;
                    case 1: // sink
                        if(abs(yspeed) &gt; 2) yspeed -= (grav*5);
                        else if(abs(yspeed) &gt; 1) yspeed -= (grav*2);
                        else if(abs(yspeed) &gt; lavaSinkSpd) yspeed -= (grav*1.5);
                        else yspeed = sign(grav)*lavaSinkSpd - grav;
                        shiftObject(combinedMoveSpd*sign(grav),0,blockCollision);
                        removeLavaStatus = 0;
                        break;
                }
            }
        }
        if(removeLavaStatus) inLava = -1;
    }
    else
    {
        with(objLava) if(!dead)
        {
            if(place_meeting(x,y,other))
            {
                other.inLava++;
            }
        }
    }
    
    // slide down or up slopes
    if(slideOffSlopesFactor != 0 &amp;&amp; ground)
    {
        var isOnSlope = 0, slopeDir = 0;
        // detect if you're on a slope
        // regular slope down: ground 1 below and 1 to the side no,
        //  ground 2 below and 1 to the side yes, ground 2 below and 2 to the side no
        if(!checkSolid(1,image_yscale) &amp;&amp; checkSolid(1,2*image_yscale) &amp;&amp; !checkSolid(2,2*image_yscale))
        {
            isOnSlope = 1;
            slopeDir = 1;
        }
        else if(!checkSolid(-1,image_yscale) &amp;&amp; checkSolid(-1,2*image_yscale) &amp;&amp; !checkSolid(-2,2*image_yscale))
        {
            isOnSlope = 1;
            slopeDir = -1;
        }
        // regular slope up: ground 1 to the side yes,
        //  ground 1 above and 1 to the side no, ground 1 above and 2 to the side yes
        if(checkSolid(1,0) &amp;&amp; !checkSolid(1,-image_yscale) &amp;&amp; checkSolid(2,-image_yscale))
        {
            isOnSlope = -1;
            slopeDir = 1;
        }
        else if(checkSolid(-1,0) &amp;&amp; !checkSolid(-1,-image_yscale) &amp;&amp; checkSolid(-2,-image_yscale))
        {
            isOnSlope = -1;
            slopeDir = -1;
        }
        // long slope down: ground 1 below and 2 to the side no,
        //  ground 2 below and 2 to the side yes, ground 2 below and 4 to the side no
        if(!checkSolid(2,image_yscale) &amp;&amp; checkSolid(2,2*image_yscale) &amp;&amp; !checkSolid(4,2*image_yscale))
        {
            isOnSlope = 0.5;
            slopeDir = 1;
        }
        else if(!checkSolid(-2,image_yscale) &amp;&amp; checkSolid(-2,2*image_yscale) &amp;&amp; !checkSolid(-4,2*image_yscale))
        {
            isOnSlope = 0.5;
            slopeDir = -1;
        }
        // long slope up: ground 2 to the side yes,
        //  ground 1 above and 2 to the side no, ground 1 above and 4 to the side yes
        if(checkSolid(2,0) &amp;&amp; !checkSolid(2,-image_yscale) &amp;&amp; checkSolid(4,-image_yscale))
        {
            isOnSlope = -0.5;
            slopeDir = 1;
        }
        else if(checkSolid(-2,0) &amp;&amp; !checkSolid(-2,-image_yscale) &amp;&amp; checkSolid(-4,-image_yscale))
        {
            isOnSlope = -0.5;
            slopeDir = -1;
        }
        // steep slope down: ground 2 below and 1 to the side no,
        //  ground 4 below and 1 to the side yes, ground 4 below and 2 to the side no
        if(!checkSolid(1,2*image_yscale) &amp;&amp; checkSolid(1,4*image_yscale) &amp;&amp; !checkSolid(2,4*image_yscale))
        {
            isOnSlope = 2;
            slopeDir = 1;
        }
        else if(!checkSolid(-1,2*image_yscale) &amp;&amp; checkSolid(-1,4*image_yscale) &amp;&amp; !checkSolid(-2,4*image_yscale))
        {
            isOnSlope = 2;
            slopeDir = -1;
        }
        // steep slope up: ground 1 to the side yes,
        //  ground 2 above and 1 to the side no, ground 2 above and 2 to the side yes
        if(checkSolid(1,0) &amp;&amp; !checkSolid(1,-2*image_yscale) &amp;&amp; checkSolid(2,-2*image_yscale))
        {
            isOnSlope = -2;
            slopeDir = 1;
        }
        else if(checkSolid(-1,0) &amp;&amp; !checkSolid(-1,-2*image_yscale) &amp;&amp; checkSolid(-2,-2*image_yscale))
        {
            isOnSlope = -2;
            slopeDir = -1;
        }
        
        xspeed += slideOffSlopesFactor*isOnSlope*grav*slopeDir;
    }
    
    // handle deceleration and turning around at walls with no deceleration
    if(true)
    {
        if(ground)
        {
            if(pushDecelGround &gt; 0)
            {
                if(!inWater &amp;&amp; xspeed != 0)
                {
                    if(abs(xspeed) &lt; pushDecelGround) xspeed = 0;
                    else xspeed -= sign(xspeed)*pushDecelGround;
                }
            }
            else if(pushDecelGround &lt; 0)
            {
                if(xspeed == 0 &amp;&amp; prevxs != 0)
                {
                    if(!checkSolid(prevxs,0))
                    {
                        xspeed = prevxs;
                    }
                }
            }
        }
        else
        {
            if(pushDecelAir &gt; 0)
            {
                if(!inWater &amp;&amp; xspeed != 0)
                {
                    if(abs(xspeed) &lt; pushDecelAir) xspeed = 0;
                    else xspeed -= sign(xspeed)*pushDecelAir;
                }
            }
            else if(pushDecelAir &lt; 0)
            {
                if(xspeed == 0 &amp;&amp; prevxs != 0)
                {
                    if(!checkSolid(prevxs,0))
                    {
                        xspeed = prevxs;
                    }
                }
            }
        }
    }
    
    // bounce off collision
    if(reboundFactorX &gt; 0)
    {
        if(xspeed == 0 &amp;&amp; prevxs != 0)
        {
            if(!checkSolid(-prevxs,0))
            {
                xspeed = -prevxs*reboundFactorX;
            }
        }
    }
    if(reboundFactorY &gt; 0)
    {
        if(yspeed == 0 &amp;&amp; prevys != 0 &amp;&amp; ground)
        {
            if(!checkSolid(0,-prevys))
            {
                yspeed = -prevys*reboundFactorY;
            }
        }
    }
    
    prevxs = xspeed;
    prevys = yspeed;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="21">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(pushable)
{
    var hasBeenPushed = false;
    for(var i = 0; i &lt; array_length_1d(pushObject); i++)
    {
        if(other.object_index == pushObject[i] || object_get_parent(other) == pushObject[i])
        {
            hasBeenPushed = 1;
            var dir = sign(other.xspeed);
            if(dir == 0) dir = other.image_xscale;
            xspeed = dir*pushForce[i];
            i = array_length_1d(pushObject);
        }
    }
    
    if(hasBeenPushed)
    {
        healthpoins = healthpointsStart;
    }
    else
    {
        other.guardCancel = 2;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="19">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
healthpoins = healthpointsStart;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_xscale = sign(image_xscale) + (image_xscale == 0);
image_yscale = sign(image_yscale) + (image_yscale == 0);
grav = abs(grav)*image_yscale;
if(stockGrav == 0) stockGrav = 0.25*image_yscale;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
