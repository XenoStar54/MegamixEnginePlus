<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtAlwaysActive</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

players = ds_list_create();
prevGravs = ds_list_create();

timer = 0;
phase = 0;
alreadyCollected = false;

playerLock = noone;
absorbSFX = noone;

// creation code
name = "";
script = scrNoEffect;
code = "";
xTarget = view_xview[0] + view_wview[0] / 2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// destroy lists
ds_list_destroy(players);
ds_list_destroy(prevGravs);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (global.frozen)
{
    exit;
}

// failsafe
if (!ds_exists(players, ds_type_list))
{
    players = ds_list_create();
}

if (!ds_exists(prevGravs, ds_type_list))
{
    prevGravs = ds_list_create();
}

// remove null player controller entries
for (var i = 0; i &lt; ds_list_size(players); i++)
{
    if (!instance_exists(ds_list_find_value(players, i)))
    {
        ds_list_delete(players, i);
        i--; // list entries are now shifted
    }
}

// behavior
switch (phase)
{
    // delay after defeating boss
    case 0:
        timer++;
        if (timer &gt;= 180)
        {
            // create controllers for each player (which locks them)
            for (var p = 0; p &lt; instance_number(objMegaman); p++)
            {
                var a = instance_create(x, y, objPlayerCutsceneController);
                a.playerObj = instance_find(objMegaman, p);
                a.playerObj.canHit = false;
                a.playerObj.dieToSpikes = false;
                ds_list_add(players, a);
                ds_list_add(prevGravs, 0); // placeholder
            }
            
            // save victory
            playMusic('Mega_Man_10.nsf', "VGM", 19, 0, 0, false, 1);
            
            alreadyCollected = indexOf(global.elementsCollected, name);
            if (!alreadyCollected)
            {
                arrayAppend(global.elementsCollected, name);
                script_execute(script);
                stringExecutePartial(code);
                
                // update count of number of elements collected:
                global.energyElements = array_length_1d(global.elementsCollected) - numberOf(global.elementsCollected, "");
            }
            
            // save the game file
            saveLoadGame(true);
            
            // next
            timer = 0;
            phase++;
        }
        
        break;
    
    // doing fanfare
    case 1:
        timer++;
        if (timer &gt;= 360)
        {
            if (alreadyCollected || global.saveFile == "" || !global.absorbOnClear)
            {
                // no weapon to absorb; just teleport out
                phase = 5;
            }
            else if (ds_list_size(players) &gt; 1)
            {
                // jump up and absorb immediately if there's multiple players
                phase = 3;
            }
            else
            {
                // go to center of room
                var p = ds_list_find_value(players, 0);
                p.xTarget = xTarget;
            
                phase++;
            }
            
            timer = 0;
        }
        
        break;
    
    // walk to center of room
    case 2:
        var areBusy = false;
        var onGround = true;
        for (var i = 0; i &lt; ds_list_size(players); i++)
        {
            var p = ds_list_find_value(players, i);
            if (!p.playerObj.ground)
            {
                onGround = false;
            }
            
            if (p.busy)
            {
                areBusy = true;
            }
        }
        
        if (!areBusy &amp;&amp; onGround)
        {
            phase++;
        }
        
        break;
    
    // initiate jump
    case 3:
        var allJump = true;
        for (var i = 0; i &lt; ds_list_size(players); i++)
        {
            var f = ds_list_find_value(players, i);
            var p = f.playerObj;
            
            with (p)
            {
                if (yspeed == 0)
                {
                    allJump = false;
                }
                
                var g;
                if (!inWater)
                {
                    g = gravAccel * gravfactor * gravDir;
                }
                else
                {
                    g = gravWater * gravfactor * gravDir;
                }
                
                if (image_yscale &gt; 0)
                {
                    yspeed = ySpeedAim(y, view_yview[0] + 32, g);
                }
                else
                {
                    yspeed = ySpeedAim(y, view_yview[0] + view_hview[0] - 32, g);
                }
            }
        }
        
        if (allJump)
        {
            phase++;
        }
        
        break;
    
    // stop at center of room and absorb
    case 4:
        var allOnGround = true;
        for (var i = 0; i &lt; ds_list_size(players); i++)
        {
            var p = ds_list_find_value(players, i).playerObj;
            
            if (!p.ground)
            {
                allOnGround = false;
            }
            
            if (ds_list_find_value(prevGravs, i) == 0)
            {
                // initiate absorb
                if ((p.image_yscale &gt; 0 &amp;&amp; p.yspeed &gt; 0 &amp;&amp; p.y &gt;= view_yview[0] + view_hview[0] / 2)
                    || (p.image_yscale &lt; 0 &amp;&amp; p.yspeed &lt; 0 &amp;&amp; p.y &lt;= view_yview[0] + view_hview[0] / 2))
                {
                    ds_list_replace(prevGravs, i, p.gravfactor);
                    
                    p.y = view_yview[0] + view_hview[0] / 2;
                    p.yspeed = 0;
                    p.gravfactor = 0;
                    
                    // create absorb effects
                    for (var j = 0; j &lt; 8; j++)
                    {
                        var a = instance_create(x, y, objBossAbsorb);
                        a.playerID = p.playerID;
                        a.angle = 45 * (j &gt;= 4) + j * 90;
                        a.angleSpd = 8;
                        a.distance = view_wview[0] / 2 + view_wview[0] / 2 * (j &gt;= 4);
                        a.moveSpd = 0.69 + 0.69 * (j &gt;= 4); // nice
                        a.targetX = bboxGetXCenterObject(p);
                        a.targetY = bboxGetYCenterObject(p);
                        a.x = a.targetX + a.distance * cos(degtorad(a.angle + 180));
                        a.y = a.targetY + a.distance * sin(degtorad(a.angle + 180));
                    }
                }
            }
            else if (p.gravfactor == 0)
            {
                // stop absorb and fall back down
                var absorbedAll = true;
                with (objBossAbsorb)
                {
                    if (playerID == p.playerID)
                    {
                        absorbedAll = false;
                    }
                } 
                
                if (absorbedAll)
                {
                    p.gravfactor = ds_list_find_value(prevGravs, i);
                }
            }
        }
        
        // sfx
        if (instance_exists(objBossAbsorb))
        {
            var play = false;
            if (absorbSFX == noone)
            {
                play = true;
            }
            else if (!audio_is_playing(absorbSFX))
            {
                play = true;
            }
            
            if (play)
            {
                absorbSFX = playSFX(sfxAbsorb, true);
            }
        }
        else if (absorbSFX != noone)
        {
            audio_stop_sound(absorbSFX);
            absorbSFX = noone;
        }
        
        // next
        if (ds_list_find_index(prevGravs, 0) &lt; 0 &amp;&amp; !instance_exists(objBossAbsorb)
            &amp;&amp; allOnGround)
        {
            phase++;
        }
        
        break;
    
    // teleport out
    case 5:
        with (objMegaman)
        {
            var p = instance_create(x, y, objMegamanExit);
            p.pid = playerID;
            p.cid = costumeID;
            
            visible = 0;
            instance_destroy();
        }
        
        instance_destroy();
        
        phase++;
        
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
