<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100000</depth>
  <persistent>-1</persistent>
  <parentName>prtAlwaysActive</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialization

//// global initialization ////
global.hudFlicker = 0

// set random seed
randomize();

// engine configuration options
engineConfig();

/// global variable setup
globalInit();

//// instance variables private to objGlobalControl ////

// fade in/out
fadeAlpha = 0;
fadestep = 0.2;
fadeinterval = 3;
fadetimer = 0;

// health bar
showhealth = 0;
increaseHealth = false;
increaseAmmo = false;
increaseTimer = 0;
increaseWeapon = 0;
depthstart = depth;
depthAlter = 0;

// save icon
saveTimer = -1;
saveFrame = 0;

// checkpoint notification
checkpointTimer = -1;

// list of pickups (prevents pickup respawning)
pickups = ds_list_create();

// used for pausing
setfrozen = 0;

// ensures global.frozen is read-only.
frozenCache = global.frozen;

// pause list
obj[0] = prtEntity;
obj[1] = prtEffect;

// public variables (these should be changed to global.)
joystick_connected = false
xinputDeviceCount = 0;

/// User-specific globals ////

// new save file
freshSaveFile();

// default options
freshOptions();

// setup shaders
setPaletteShader = false;
enforcedPalette = shader_get_sampler_index(shdPaletteEnforcer, "palette");
enforcedPaletteLength = shader_get_uniform(shdPaletteEnforcer, "paletteLength");
pltSurface = noone;

global.crtSurfaceScale = 6;

global.crtSurfaceWidth  = global.screenWidth * global.crtSurfaceScale;
global.crtSurfaceHeight = global.screenHeight * global.crtSurfaceScale;

global.crtDistort = true;
global.crtDistortionAmount = 0.12;
global.crtBorder = true; // there's really no good reason to make this toggleable

uni_crt_sizes = shader_get_uniform(shdCRT, "u_crt_sizes");
distort = shader_get_uniform(shdCRT, "distort");
distortion = shader_get_uniform(shdCRT, "distortion");
border = shader_get_uniform(shdCRT, "border");

crtSurface = noone;

greyscaleSurface = noone;

monoPalette = shader_get_sampler_index(shdMonochromePaletteEnforcer, "palette");
monoPaletteLength = shader_get_uniform(shdMonochromePaletteEnforcer, "paletteLength");
gbSurface = noone;

shdFadeShift = shader_get_uniform(shdColorSubtractStep, "fadeShift");
fadeSurface = noone;

// load user's options (if they exist)
saveLoadOptions(false);

/// set up display ///

setScreenSize(global.screenSize);
application_surface_draw_enable(false);
display_reset(0, global.vsync);

//// Create other control objects ////
instance_create(0, 0, objMusicControl);
instance_create(0, 0, objDebugControl);
instance_create(0, 0, objMobileControl);

//Used to load a room passed as parameter
init = 1;

// discord rich presence
discord_init_dll()
discord_init_app("854104021752086578")
global.richPresenceSet = false;
discord_update_presence("Megamix Plus","","megamixplusdiscord","")

// show disclaimer
room_goto(rmDisclaimer);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Auto-update Rich Presence
if (!global.richPresenceSet)
{
    // update
    discord_update_presence(roomGetNameFormatted(room), "", "megamixplusdiscord", "");
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// death -- restart
global.nextRoom = global.checkpoint;

// game over
if (global.livesRemaining &lt;= 0 &amp;&amp; global.livesEnabled &amp;&amp; global.inGame)
{
    // recordings should stop
    if (global.recordInputMode != 0)
    {
        global.recordInputDeath = true;
    }
    else
    {
        global.nextRoom = rmGameOver;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// camera update, flicker, and fade

if (!instance_exists(objSectionSwitcher) &amp;&amp; global.inGame)
{
    // Camera
    playerCamera(1);
    
    // screen shaking
    if (!global.frozen)
    {
        view_xview[0] += choose(-global.shakeFactorX, 0, global.shakeFactorX);
        view_yview[0] += choose(-global.shakeFactorY, 0, global.shakeFactorY);
    }
    
    with (prtCustomCamera)
    {
        event_user(0);
    }
}

// Flicker
depthAlter = !depthAlter;
if (depthAlter &amp;&amp; global.hudFlicker)
{
    depth = 10;
}

for (i = 0; i &lt;= 1; i += 1)
{
    with (obj[i])
    {
        if (depth &lt; 100000 &amp;&amp; !noFlicker)
        {
            depth = floor(depth) + (irandom(99) * 0.01);
        }
    }
}

if (global.nextRoom != 0 || fadeAlpha &gt; 0)
{
    fadetimer += 1;
    if (fadetimer &gt;= fadeinterval)
    {
        if (global.nextRoom &amp;&amp; fadeAlpha == 1)
        {
            global.previousRoom = room;
            room_goto(global.nextRoom);
        }
        
        fadeAlpha += fadestep * (1 - (2 * (global.nextRoom == 0)));
        fadeAlpha = max(0, min(1, fadeAlpha));
        
        fadetimer = 0;
        if (fadeAlpha == 1)
        {
            fadetimer = -5;
        }
        else if (global.nextRoom == 0 &amp;&amp; fadeAlpha == 0)
        {
            if (!instance_exists(objPauseMenu))
            {
                queueUnpause();
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load room from parameter
if(init &amp;&amp; room == rmDisclaimer)
{
    init=0;
    if(parameter_count()&gt;1)
    {
        if (parameter_string(1) == "--test")
        {
            room_goto(rmUnitTest);
        }
        var filename = "+" + parameter_string(1);
        if(filename!="+" &amp;&amp; stringEndsWith(filename,".room.gmx"))
        {
        
            var nrm = roomExternalLoad(filename);
            goToLevel(nrm);
            exit;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// revert camera effects

if (!instance_exists(objSectionSwitcher) &amp;&amp; global.inGame)
{
    view_xview[0] = global.cachedXView;
    view_yview[0] = global.cachedYView;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// global timers

global.roomTimer += 1;
global.gameTimer += 1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// player input
// Inputs

// Gamepad info
xinputDeviceCount = 0;
for (var i = 0; i &lt; 4; i++)
{
    if (gamepad_is_connected(i))
        xinputDeviceCount++;
}

var n_connected = 0;
for (var i = 0; i &lt; gamepad_get_device_count(); i += 1)
{
    if (gamepad_is_connected(i))
        n_connected += 1;
}

n_connected = min(n_connected, global.playerCount);
for (i = 0; i &lt; global.playerCount; i += 1)
{
    
    // lock player controls
    var doLock = false;
    if (!instance_exists(objDebugMenu))
    {
        with (objPlayerCutsceneController)
        {
            if (instance_exists(playerObj))
            {
                if (playerObj.playerID == i)
                {
                    doLock = true;
                }
            }
        }
    }
    
    if (doLock)
    {
        continue;
    }
    
    // Input
    var keyLeftHold = global.keyLeft[i];
    var keyRightHold = global.keyRight[i];
    var keyUpHold = global.keyUp[i];
    var keyDownHold = global.keyDown[i];
    var keyJumpHold = global.keyJump[i];
    var keyShootHold = global.keyShoot[i];
    var keySlideHold = global.keySlide[i];
    var keyPauseHold = global.keyPause[i];
    var keyWeaponSwitchLeftHold = global.keyWeaponSwitchLeft[i];
    var keyWeaponSwitchRightHold = global.keyWeaponSwitchRight[i];
    
    // Check keys
    global.keyLeft[i] = keyboard_check(global.leftKey[i]);
    global.keyRight[i] = keyboard_check(global.rightKey[i]);
    global.keyUp[i] = keyboard_check(global.upKey[i]);
    global.keyDown[i] = keyboard_check(global.downKey[i]);
    global.keyJump[i] = keyboard_check(global.jumpKey[i]);
    global.keyShoot[i] = keyboard_check(global.shootKey[i]);
    global.keySlide[i] = keyboard_check(global.slideKey[i]);
    global.keyPause[i] = keyboard_check(global.pauseKey[i])
        || (keyboard_check_pressed(vk_escape)
        &amp;&amp; global.escapeBehavior == 1);
    global.keyWeaponSwitchLeft[i] = keyboard_check(
        global.weaponSwitchLeftKey[i]);
    global.keyWeaponSwitchRight[i] = keyboard_check(
        global.weaponSwitchRightKey[i]);
    
    var jp = i;
    
    if (n_connected &gt; 0)
    {
        if (!gamepad_is_connected(jp))
        {
            jp += 4 - xinputDeviceCount;
        }
        
        if (gamepad_is_connected(jp))
        {
            if (gamepad_axis_count(jp) &gt;= 2)
            {
                // Check D-Pad first
                var dPad = gamepad_button_check(jp, gp_padu) || gamepad_button_check(jp, gp_padl) || gamepad_button_check(jp, gp_padr) || gamepad_button_check(jp, gp_padd);
                if (dPad)
                {
                    global.keyLeft[i] = global.keyLeft[i] || gamepad_button_check(jp, gp_padl);
                    global.keyRight[i] = global.keyRight[i] || gamepad_button_check(jp, gp_padr);
                    global.keyUp[i] = global.keyUp[i] || gamepad_button_check(jp,gp_padu);
                    global.keyDown[i] = global.keyDown[i] || gamepad_button_check(jp,gp_padd);
                }
                
                if (joystick_has_pov(jp))
                {
                    var angle = joystick_pov(jp);
                    if (angle != -1)
                    {
                        dPad = true;
                        
                        switch (angle)
                        {
                            case 0:
                                global.keyUp[i] = true;
                                break;
                            case 45:
                                global.keyRight[i] = true;
                                global.keyUp[i] = true;
                                break;
                            case 90:
                                global.keyRight[i] = true;
                                break;
                            case 135:
                                global.keyDown[i] = true;
                                global.keyRight[i] = true;
                                break;
                            case 180:
                                global.keyDown[i] = true;
                                break;
                            case 225:
                                global.keyLeft[i] = true;
                                global.keyDown[i] = true;
                                break;
                            case 270:
                                global.keyLeft[i] = true;
                                break;
                            case 315:
                                global.keyLeft[i] = true;
                                global.keyUp[i] = true;
                                break;
                        }
                    }
                }
                
                // Analog Stick position
                if (gamepad_axis_count(jp) &gt;= 2)
                {
                    if (!dPad)
                    {
                        var axX = gamepad_axis_value(jp, gp_axislh);
                        var axY = gamepad_axis_value(jp, gp_axislv);
                        if ((abs(axY) &gt; 0.4) || (abs(axX) &gt; 0.36))
                        {
                            gamepadStick = point_direction(0, 0, axX, axY);
                            global.keyLeft[i] = global.keyLeft[i] || (gamepadStick &gt;= 120
                                &amp;&amp; gamepadStick &lt;= 240);
                            global.keyRight[i] = global.keyRight[i] || ((gamepadStick &lt;= 60)
                                || gamepadStick &gt;= 300);
                            global.keyUp[i] = global.keyUp[i] || (gamepadStick &gt;= 30
                                &amp;&amp; gamepadStick &lt;= 150);
                            global.keyDown[i] = global.keyDown[i] || (gamepadStick &gt;= 210
                                &amp;&amp; gamepadStick &lt;= 330);
                        }
                    }
                }
            }
            
            global.keyJump[i] = global.keyJump[i] || gamepad_button_check(jp,
                global.joystick_jumpKey[i]);
            global.keyShoot[i] = global.keyShoot[i] || gamepad_button_check(jp,
                global.joystick_shootKey[i]);
            global.keySlide[i] = global.keySlide[i] || gamepad_button_check(jp,
                global.joystick_slideKey[i]);
            global.keyPause[i] = global.keyPause[i] || gamepad_button_check(jp,
                global.joystick_pauseKey[i]);
            global.keyWeaponSwitchLeft[i] = global.keyWeaponSwitchLeft[i] || gamepad_button_check(jp,
                global.joystick_weaponSwitchLeftKey[i]);
            global.keyWeaponSwitchRight[i] = global.keyWeaponSwitchRight[i] || gamepad_button_check(jp,
                global.joystick_weaponSwitchRightKey[i]);
        }
    }
    
    // Key pressed stuff
    global.keyLeftPressed[i] = global.keyLeft[i] &amp;&amp; !keyLeftHold;
    global.keyRightPressed[i] = global.keyRight[i] &amp;&amp; !keyRightHold;
    global.keyUpPressed[i] = global.keyUp[i] &amp;&amp; !keyUpHold;
    global.keyDownPressed[i] = global.keyDown[i] &amp;&amp; !keyDownHold;
    global.keyJumpPressed[i] = global.keyJump[i] &amp;&amp; !keyJumpHold;
    global.keyShootPressed[i] = global.keyShoot[i] &amp;&amp; !keyShootHold;
    global.keySlidePressed[i] = global.keySlide[i] &amp;&amp; !keySlideHold;
    global.keyPausePressed[i] = global.keyPause[i] &amp;&amp; !keyPauseHold;
    global.keyWeaponSwitchLeftPressed[i] = global.keyWeaponSwitchLeft[i]
        &amp;&amp; !keyWeaponSwitchLeftHold;
    global.keyWeaponSwitchRightPressed[i] = global.keyWeaponSwitchRight[i]
        &amp;&amp; !keyWeaponSwitchRightHold;
}

// recorded controls dubbing:
recordInputHandle();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// freeze / unfreeze game objects
/// counteracts game maker automatically updating built-in variables.

assert(global.frozen == frozenCache, "global.frozen was modified directly. Use queuePause() or queueUnpause() instead.");

// change global.frozen state.
if (global.queuePaused == 1)
{
    global.frozen = true;
}
if (global.queuePaused == -1)
{
    global.frozen = false;
}
global.queuePaused = 0;
frozenCache = global.frozen;

if (global.frozen)
{
    var len = array_length_1d(obj);
    for (i = 0; i &lt; len; i += 1)
    {
        with (obj[i])
        {
            if (!frozen) // Start Freeze
            {
                pre_hsp = hspeed;
                pre_vsp = vspeed;
                pre_spe = speed;
                pre_isp = image_speed;
                hspeed = 0;
                vspeed = 0;
                speed = 0;
                image_speed = 0;
                frozen = 1;
            }
            
            for (var _i = 0; _i &lt;= 11; _i += 1)
            {
                if (alarm[_i] &gt; 0)
                {
                    alarm[_i] += 1;
                }
            }
        }
    }
    setfrozen = 1;
}
else if (setfrozen) // Stop Freeze
{
    var len = array_length_1d(obj);
    for (i = 0; i &lt; len; i += 1)
    {
        with (obj[i])
        {
            if (frozen)
            {
                hspeed = pre_hsp;
                vspeed = pre_vsp;
                speed = pre_spe;
                image_speed = pre_isp;
                frozen = 0;
            }
        }
    }
    setfrozen = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Respawn players
if (global.frozen)
{
    exit;
}

global.respawnAllowed = false;

with (objMegaman)
{
    if (gravDir &gt; 0)
    {
        global.respawnAllowed = true;
    }
}

with (objMegaman)
{
    if (global.playerHealth[playerID] &gt; global.respawnDonateThreshold)
    {
        global.respawnAllowed = true;
    }
    if (playerIsLocked(PL_LOCK_PAUSE))
    {
        global.respawnAllowed = false;
    }
}

if (instance_exists(objAutoScroller))
{
    global.respawnAllowed = false;
}

for (i = 0; i &lt; global.playerCount; i += 1)
{
    if (global.respawnTimer[i] &gt;= 0)
    {
        if (global.respawnTimer[i])
        {
            global.respawnTimer[i] -= 1;
            if (!instance_exists(objMegaman))
            {
                global.respawnTimer[i] = -1;
            }
        }
        
        if (!instance_exists(prtBoss)
            &amp;&amp; global.respawnTimer[i] &gt; global.respawnTime)
        {
            global.respawnTimer[i] = global.respawnTime;
        }
        
        if (global.keyPausePressed[i] &amp;&amp; global.respawnAllowed
            &amp;&amp; !global.respawnTimer[i])
        {
            // Check no existing player already has this id
            var nogo = false;
            with (objMegaman)
            {
                if (playerID == i)
                {
                    nogo = true;
                }
            }
            if (nogo)
            {
                continue;
            }
            
            if (!global.respawnAllowed)
            {
                playSFX(sfxError);
                continue;
            }
            playSFX(sfxMenuSelect);
            
            // determine respawn health:
            var donators = 1;
            var respawn_health = 0;
            
            with (objMegaman)
            {
                if (global.playerHealth[playerID]
                    &gt; global.respawnDonateThreshold)
                {
                    donators += 1;
                }
            }
            with (objMegaman)
            {
                var donate = floor(global.playerHealth[playerID] / donators)
                    * (global.playerHealth[playerID]
                    &gt; global.respawnDonateThreshold);
                respawn_health += donate;
                global.playerHealth[playerID] -= donate;
            }
            
            // respawn player at random other player's coords
            var targetPlayer = instance_find(objMegaman,
                irandom(instance_number(objMegaman) - 1));
            var prev_checkpoint = global.checkpoint;
            global.checkpoint = -1;
            
            var p = instance_create(targetPlayer.x, targetPlayer.y, objMegaman);
            p.gravfactor = targetPlayer.gravfactor;
            p.inWater = targetPlayer.inWater;
            p.grav = targetPlayer.grav;
            p.gravWater = targetPlayer.gravWater;
            with (p)
            {
                // teleporting init
                teleportLock = lockPoolLock(
                    PL_LOCK_MOVE,
                    PL_LOCK_PHYSICS,
                    PL_LOCK_SHOOT,
                    PL_LOCK_CLIMB,
                    PL_LOCK_CHARGE,
                    PL_LOCK_PAUSE,
                    PL_LOCK_TURN,
                    PL_LOCK_GRAVITY);
                teleportLock.targetInstance = id
                canHit = false;
            }
            
            global.checkpoint = prev_checkpoint;
            p.playerID = i;
            global.playerHealth[i] = respawn_health;
            global.respawnTimer[i] = -1;
            objGlobalControl.alarm[0] = -1;
            global.decrementLivesOnRoomEnd = false;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// energy handling and screen shake

x = view_xview[0] + 16;
y = view_yview[0] + 16;

// Infinite energy handling
for (i = 0; i &lt;= global.totalWeapons; i += 1)
{
    if (global.infiniteEnergy[i])
    {
        for (var j = 0; j &lt; global.playerCount; j += 1)
        {
            global.ammo[j, i] = 28;
        }
    }
}

if (increaseHealth || increaseAmmo) // Increase Health and/or Ammo
{
    if (global.healthEffect) // Instant
    {
        if (increaseHealth)
        {
            global.playerHealth[increasePID] = ceil(global.playerHealth[increasePID] + increaseHealth);
            playSFX(sfxEnergyRestore);
            
            increaseHealth = 0;
        }
        if (increaseAmmo)
        {
            global.ammo[increasePID, increaseWeapon] = ceil(global.ammo[increasePID, increaseWeapon] + increaseAmmo);
            playSFX(sfxEnergyRestore);
            
            increaseAmmo = 0;
        }
    }
    else
    {
        increaseTimer += 1;
        
        if (!(increaseTimer mod 3))
        {
            increaseHealth *= (global.playerHealth[increasePID] &lt; 28);
            if (increaseHealth)
            {
                global.playerHealth[increasePID] = floor(global.playerHealth[increasePID]) + 1;
                increaseHealth = max(increaseHealth - 1, 0);
            }
            increaseAmmo *= (global.ammo[increasePID, increaseWeapon] &lt; 28);
            if (increaseAmmo)
            {
                global.ammo[increasePID, increaseWeapon] = floor(global.ammo[increasePID, increaseWeapon]) + 1;
                increaseAmmo = max(increaseAmmo - 1, 0);
            }
        }
    }
    
    if (!increaseHealth &amp;&amp; !increaseAmmo)
    {
        queueUnpause();
        increaseTimer = 0;
        if (!global.healthEffect)
        {
            audio_stop_sound(sfxEnergyRestore);
        }
    }
    
    // make sure ammo never goes past 28
    if (global.playerHealth[increasePID] &gt; 28)
    {
        global.playerHealth[increasePID] = 28;
    }
    
    if (global.ammo[increasePID, increaseWeapon] &gt; 28)
    {
        global.ammo[increasePID, increaseWeapon] = 28;
    }
}

// Screen shake handling
if (!global.frozen)
{
    if (global.shakeTimer &gt; 0)
    {
        global.shakeTimer -= 1;
    }
    else
    {
        global.shakeFactorX = 0;
        global.shakeFactorY = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>cleanMem('clean');

setfrozen = 0;

if (global.endStageOnRoomEnd)
{
    stageEnd();
}
else if (global.decrementLivesOnRoomEnd)
{
    // lose a life
    if (global.inGame)
    {
        global.livesRemaining--;
    }
    global.decrementLivesOnRoomEnd = false;
    if (global.livesRemaining &lt; 0)
    {
        global.inGame = false;
    }
}

// objMegaman clean-up
with (objMegaman)
    instance_destroy();

// weapon clean up
for (i = 0; i &lt;= global.playerCount; i += 1)
{
    global.weapon[i] = 0;
}

global.lockBuster = false;

global.timeStopped = false;

// forcibly reset control locks
globalLockReset();

// prepare update of discord rich presence (give time for room creation code to set it manually)
global.richPresenceSet = false;
alarm[1] = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// setup room, spawn players, etc.
joystick_connected = false;
if (joystick_exists(1))
{
    joystick_connected = true;
}

// global.frozen = false;
global.aliveBosses = 0;

global.lockTransition = false;
global.switchingSections = false;

global.keyCoinTotal = 0;
global.keyCoinCollected = 0;
global.keyNumber = 0;

global.nextRoom = 0;

view_wview[0] = min(global.screenWidth, room_width);
view_hview[0] = min(global.screenHeight, room_height);

room_speed = global.gameSpeed;

showhealth = 0;
global.roomTimer = 0;

// begin level if flag set
if (global.beginStageOnRoomBegin &amp;&amp; global.hasTeleported)
{
    // Delete this if you actually desire levels to begin by teleporter.
    // (Note that MaGMML-esque hub teleporters should not trigger this because they should not set hasTeleported to true.)
    printErr("Warning: A new stage began by teleporting in. This is probably not intended behaviour. See objGlobalControl:Room Start event for details.");
}

global.inGame = (instance_exists(objDefaultSpawn) || global.hasTeleported);

assert(!global.beginStageOnRoomBegin || global.inGame, "Began a stage but nowhere for player to spawn: " + roomExternalGetName(room));

if (global.inGame)
{
    if (DEBUG_SPAWN)
        show_debug_message("Level Start (objGlobalControl) " + roomExternalGetName(room));
    showhealth = 1;
    
    // set room settings
    view_enabled = true;
    view_visible[0] = true;
    room_speed = 60;
    
    // quadrant size
    for (i = 0; i &lt;= 7; i += 1)
    {
        if (string_pos("bgQuad", background_get_name(background_index[i])) == 1)
        {
            global.quadWidth = background_get_width(background_index[i]);
            global.quadHeight = background_get_height(background_index[i]);
            global.quadMarginTop = (global.quadHeight - view_hview[0]) / 2;
            global.quadMarginBottom = global.quadMarginTop;
            background_index[i] = -1;
        }
    }
    
    view_wview[0] = global.quadWidth;
    
    // Destroy collected pickups
    var str, slash, totalPickups;
    
    totalPickups = ds_list_size(pickups);
    for (var i = 0; i &lt;= totalPickups; i += 1)
    {
        str = ds_list_find_value(pickups, i);
        if (!is_string(str))
        {
            break;
        }
        slash = string_pos('/', str);
        if (room == real(string_copy(str, 1, slash - 1)))
        {
            with (real(string_delete(str, 1, slash)))
            {
                visible = 0;
                instance_destroy();
            }
        }
    }
    
    // Place section borders
    for (var v = 0; v &lt; room_height; v += global.quadHeight)
        for (var i = 0; i &lt; room_width; i += global.quadWidth)
        {
            with (instance_create(i, v, objStopScrollingVertical))
            {
                image_xscale = global.quadWidth / sprite_get_width(sprite_index);
            }
        }
    
    // Delete vertical border to make vertical scrolling possible
    with (objStopScrollingVertical)
    {
        if (place_meeting(x, y, objSectionFreeVerticalScrolling))
        {
            instance_destroy();
        }
    }
    
    // Connect Horizontal borders
    /*with (objStopScrollingHorizontal)
    {
        if (!place_meeting(x, y - 12, object_index))
        {
            while (place_meeting(x, y + 12, object_index))
            {
                with (instance_place(x, y + 12, object_index))
                {
                    other.image_yscale += image_yscale;
                    instance_destroy();
                }
            }
        }
    }*/
    
    ds_list_clear(global.borderlist);
    
    with (objStopScrollingHorizontal)
    {
        ds_list_add(global.borderlist, "h" + string(x) + "s" + string(y) + "e" + string(y + sprite_height));
        instance_destroy();
    }
    with (objStopScrollingVertical)
    {
        ds_list_add(global.borderlist, "v" + string(y) + "s" + string(x) + "e" + string(x + sprite_width));
        instance_destroy();
    }
    
    // determine starting location
    var spawn_x, spawn_y;
    
    // three ways to enter a room: teleporting, respawning, or level start
    if (global.hasTeleported)
    {
        // just teleported in
        if (global.teleportX || global.teleportY)
        {
            spawn_x = global.teleportX;
            spawn_y = global.teleportY;
        } // if coordinates were not specified, use the DefaultSpawn coordinates
        else
        {
            assert(instance_exists(objDefaultSpawn));
            spawn_x = objDefaultSpawn.x;
            spawn_y = objDefaultSpawn.y;
        }
    }
    else 
    {
        if (global.checkpoint == room)
        {
            // respawn after death
            spawn_x = global.checkpointX;
            spawn_y = global.checkpointY;
        
            // reset health
            for (var i = 0; i &lt; global.playerCount; i++)
            {
                global.playerHealth[i] = 28;
            }
        }
        else
        {
            // Level start. Use default spawn location.
            global.checkpoint = room;
            global.checkpointX = objDefaultSpawn.x;
            global.checkpointY = objDefaultSpawn.y;
            global.respawnAnimation = objDefaultSpawn.respawnAnimation;
            global.freeMovement = false;
            if (instance_exists(objMegaman))
            {
                objMegaman.showDuringReady = objDefaultSpawn.showDuringReady;
            }
            spawn_x = global.checkpointX;
            spawn_y = global.checkpointY;
        
            stageStart();
        }
    }
    
    // Create players
    for (var i = 0; i &lt; global.playerCount; i += 1)
    {
        if (global.playerHealth[i] &lt;= 0)
        {
            continue;
        }
        
        with (instance_create(spawn_x, spawn_y, objMegaman))
        {
            playerID = i;
            readyTimer -= playerID * 12;
            
            if (global.hasTeleported)
            {
                showReady = false;
                teleporting = true;
                landy = y;
            }
            else
            {
                // teleport in
                showReady = true;
                readyTimer = 0;
                canHit = false;
            }
            
            teleportLock = lockPoolLock(
                PL_LOCK_MOVE,
                PL_LOCK_PHYSICS,
                PL_LOCK_SHOOT,
                PL_LOCK_CLIMB,
                PL_LOCK_CHARGE,
                PL_LOCK_PAUSE,
                PL_LOCK_TURN,
                PL_LOCK_GRAVITY
            );
            teleportLock.targetInstance = id
            
            playerPalette();
        }
    }
    
    // combine objects to save on CPU
    combineObjects(objSolid);
    combineObjects(objSpike);
    combineObjects(objDamageSpike);
    combineObjects(objIce);
    combineObjects(objWater);
    combineObjects(objStandSolid);
    combineObjects(objTopSolid, true, false);
    combineObjects(objLadder, false, true);
    with (prtBossDoor)
        event_user(3);
    
    setSection(spawn_x, spawn_y, 1);
    playerCamera(1);
    
    // defer deactivating objects until after room start
    // this allows objects with room start events to run those
    var activate;
    activate[0] = 2;
    activate[1] = 1;
    defer(ev_step, ev_step_begin, depth, reAndDeactivateObjects, activate);
    with (prtEntity)
    {
        beenOutsideView = true;
        dead = true;
    }
    global.hasTeleported = false;
}
else
{
    global.absorbOnClear = false;
}

// set global screen size based on the room's view
var preW = global.screenWidth;
var preH = global.screenHeight;
global.screenWidth = view_wview[0];
global.screenHeight =  view_hview[0];

// if the new room's view size is different, adjust the screen size accordingly
if (preW != global.screenWidth || preH != global.screenHeight)
{
    setScreenSize(global.screensize);
    
    // workaround to fix the application position not updating while in fullscreen
    if (window_get_fullscreen())
    {
        window_set_fullscreen(false);
        setFullscreen(true);
    }
}

// next room should not launch a new level
global.beginStageOnRoomBegin = false;
global.beginHubOnRoomBegin = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Save game
saveLoadOptions(true);
saveLoadGame(true);

// End cleanMem
cleanMem('clear');
cleanMem('free');

// end rich presence
discord_free_app()
discord_free_dll()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Game, apply filters, and do Shader Fade Out

// app position stuff
var appPosition = application_get_position();

var appWidth = (appPosition[2] - appPosition[0]) * getPixelRatio();
var appHeight = appPosition[3] - appPosition[1];
var appX = appPosition[0] + ((appPosition[2] - appPosition[0]) - appWidth) / 2;
var appY = appPosition[1];
if (window_get_fullscreen())
{
    if (global.accurateFullscreen)
    {
        var d = 0;
        do
        {
            // lock to highest whole-number scale
            appWidth = (((appPosition[2] - appPosition[0]) div global.screenWidth) - d) * global.screenWidth * getPixelRatio();
            appHeight = (((appPosition[3] - appPosition[1]) div global.screenHeight) - d) * global.screenHeight;
            
            // try smaller scales until we're within screen limits
            d++;
        }
        until ((appWidth &lt;= display_get_width() &amp;&amp; appHeight &lt;= display_get_height()) || appHeight &lt;= global.screenHeight)
    }
    else if (appWidth &gt; display_get_width())
    {
        // change app position if too wide due to pixel ratio (gms will automatically adjust app position otherwise)
        appWidth = display_get_width();
        appHeight = (display_get_width() / getPixelRatio()) * global.screenHeight / global.screenWidth;
    }

    // fullscreen app position
    appX = (display_get_width() - appWidth) / 2;
    appY = (display_get_height() - appHeight) / 2;
}

// how many times application_surface is stretched (ignoring pixel ratio)
var multiply = appHeight / surface_get_height(application_surface);

// surfaces
var finalSurface = application_surface;
var surfaceWidth = surface_get_width(application_surface);
var surfaceHeight = surface_get_height(application_surface);

// apply shaders
draw_enable_alphablend(false);

if (global.shadersEnabled)
{
    // enforce palette
    if (global.enforcePalette &gt; 0)
    {
        var plt = pltNES;
        var pltLength = 56;
        switch (global.enforcePalette)
        {
            default:
            case 1: plt = pltNES; pltLength = 56; break;
            case 2: plt = pltMM9_10; pltLength = 52; break;
        }
        
        // make surface
        if (!surface_exists(pltSurface))
        {
            var p = powerOfTwo(surfaceWidth, surfaceHeight);
            pltSurface = surface_create(p, p);
            surface_resize(pltSurface, surfaceWidth, surfaceHeight); // crt filter messes up if the surface doesn't have exact screen dimensions
        }
        
        // apply shader
        surface_set_target(pltSurface);
        
        shader_set(shdPaletteEnforcer);
        texture_set_stage(enforcedPalette, sprite_get_texture(plt, 0));
        shader_set_uniform_f(enforcedPaletteLength, pltLength);
        draw_surface(finalSurface, 0, 0);
        shader_reset();
        
        surface_reset_target();
        
        // set to new final surface
        finalSurface = pltSurface;
    }
    
    // fade
    fadeShift = floor(fadeAlpha / fadestep); // lazy replacement of fadeAlpha code, lol
    if (fadeShift &gt; 0)
    {
        if (!surface_exists(fadeSurface))
        {
            var p = powerOfTwo(surfaceWidth, surfaceHeight);
            fadeSurface = surface_create(p, p);
            surface_resize(fadeSurface, surfaceWidth, surfaceHeight); // crt filter messes up if the surface doesn't have exact screen dimensions
        }
        
        surface_set_target(fadeSurface);
        
        //shader_set(shdColorSubtract);
        //var subtract = shader_get_uniform(shdColorSubtract, "subtractColor");
        //shader_set_uniform_f(subtract, fadeAlpha, fadeAlpha, fadeAlpha);
        shader_set(shdColorSubtractStep);
        shader_set_uniform_f(shdFadeShift, fadeShift);
        draw_surface(finalSurface, 0, 0);
        shader_reset();
        
        surface_reset_target();
        
        // set to new final surface
        finalSurface = fadeSurface;
    }
    
    // filters
    if (global.filter &gt; 0)
    {
        switch (global.filter)
        {
            // interpolation
            case 1:
                // done at the bottom with a gms function
                break;
                
            // CRT filter
            case 2:
                if (!surface_exists(crtSurface))
                {
                    var s = powerOfTwo(global.crtSurfaceWidth, global.crtSurfaceHeight);
                    crtSurface = surface_create(s, s);
                }
                
                surface_set_target(crtSurface);
                
                shader_set(shdCRT);
                shader_set_uniform_f(uni_crt_sizes, global.screenWidth, global.screenHeight, global.crtSurfaceWidth, global.crtSurfaceHeight);
                shader_set_uniform_f(distort, global.crtDistort);
                shader_set_uniform_f(distortion, global.crtDistortionAmount);
                shader_set_uniform_f(border, global.crtBorder);
                draw_surface_part_ext(finalSurface, 0, 0, surface_get_width(application_surface), surface_get_height(application_surface), 0, 0, global.crtSurfaceScale, global.crtSurfaceScale, c_white, 1);
                shader_reset();
                
                surface_reset_target();
                
                // set this as the new surface to draw
                finalSurface = crtSurface;
                multiply = appHeight / global.crtSurfaceHeight;
                surfaceWidth = global.crtSurfaceWidth;
                surfaceHeight = global.crtSurfaceHeight;
                
                break;
            
            // greyscale
            case 3:
            // virtual boy
            /* vb palette doesn't work well with palette enforcing. It doesn't
            have enough colors and it's colors are too similar to differentiate
            well so we're just going to make it greyscale and blend it with red
            later*/
            case 5:
                if (!surface_exists(greyscaleSurface))
                {
                    var s = powerOfTwo(surfaceWidth, surfaceWidth);
                    greyscaleSurface = surface_create(s, s);
                    surface_resize(greyscaleSurface, surfaceWidth, surfaceHeight);
                }
                
                surface_set_target(greyscaleSurface);
                
                shader_set(shdGreyscale);
                draw_surface(finalSurface, 0, 0);
                shader_reset();
                
                surface_reset_target();
                
                // set this as the new surface to draw
                finalSurface = greyscaleSurface;
                
                break;
            
            // gameboy
            case 4:
                if (!surface_exists(gbSurface))
                {
                    s = powerOfTwo(surfaceWidth, surfaceWidth);
                    gbSurface = surface_create(s, s);
                    surface_resize(gbSurface, surfaceWidth, surfaceHeight);
                }
                
                surface_set_target(gbSurface);
                
                shader_set(shdMonochromePaletteEnforcer);
                texture_set_stage(monoPalette, sprite_get_texture(pltGameBoy, 0));
                shader_set_uniform_f(monoPaletteLength, 5);
                draw_surface(finalSurface, 0, 0);
                shader_reset();
                
                surface_reset_target();
                
                // set this as the new surface to draw
                finalSurface = gbSurface;
                
                break;
        }
    }
}

// draw border graphic
texture_set_interpolation(true);
if (window_get_fullscreen())
{
    if (global.borderGraphic &gt; 0)
    {
        draw_background_stretched(getBorderGraphic(), 0, 0, display_get_width(), display_get_height());
    }
    else
    {
        draw_set_color(c_black);
        draw_rectangle(0, 0, display_get_width(), display_get_height(), false);
        draw_set_color(c_white);
    }
}

// Note: interpolation isn't noticeable at window resolution when the window is big.
texture_set_interpolation(global.filter == 1 || (global.filter == 2 &amp;&amp; global.shadersEnabled)); // always interpolate with crt filter

var c = c_white;
if (global.filter == 5 &amp;&amp; global.shadersEnabled)
{
    c = make_color_hsv(0, 255, 255) // hue and sat accurate to vb palette
}

var xscale = round(surfaceWidth * multiply * getPixelRatio()) / surfaceWidth;
var yscale = round(surfaceHeight * multiply) / surfaceHeight;
draw_surface_part_ext(finalSurface, 0, 0, surfaceWidth, surfaceHeight, appX, appY, xscale, yscale, c, 1);

// cleanup
texture_set_interpolation(false); // ONLY DRAW THE FINAL SURFACE WITH INTERPOLATION
if (surface_exists(fadeSurface))
{
    surface_free(fadeSurface);
}

draw_enable_alphablend(true);

// Screenshot
with (objDebugControl)
{
    if (keyboard_check_pressed(vk_f9))
    {
        while (file_exists(working_directory + "\screenshots\screenshot" + string(screenshotNum) + ".png"))
            screenshotNum += 1;
        screen_save_part(working_directory + "\screenshots\screenshot" + string(screenshotNum) + ".png",
            appX, appY, surfaceWidth * xscale, surfaceHeight * yscale);
        print("SCREENSHOT SAVED", WL_SHOW, c_orange);
        playSFX(sfxKeyGet);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_halign(fa_center);

if (global.showControllerOverlay)
{
    drawControllerOverlay(view_xview + view_wview - 28, view_yview + view_hview);
}

// Show FPS
if (global.showFPS)
{
    draw_set_halign(fa_right);
    draw_set_valign(fa_bottom);
    draw_text(view_xview + view_wview - (28 - ((global.showControllerOverlay == 0) * 28)) - ((global.showControllerOverlay == 1) * 4), view_yview + view_hview,
        string(fps));
}

draw_set_valign(fa_top);
draw_set_halign(fa_center);

// Save icon
if (saveTimer &gt;= 0)
{
    saveTimer -= 0.5;
    draw_sprite(sprSavingIcon, saveFrame, view_xview + 2 + 7, view_yview + 224 - 16 + 5);
    draw_text(view_xview + 16 + 32 + 4 + 2, view_yview + 224 - 10 - 4, "SAVING...");
    
    if (saveTimer mod 4 == 0)
    {
        saveFrame = !saveFrame;
    }
}

// Checkpoint notification
if (checkpointTimer &gt;= 0)
{
    checkpointTimer -= 0.4;
    draw_set_halign(fa_left);
    draw_text(view_xview[0]+48+(max(floor(18-checkpointTimer), 1)*8), view_yview[0]+8+(global.checkpointNotification-1)*100, string_copy("CHECKPOINT REACHED", max(floor(18-checkpointTimer), 1), min(floor(60-checkpointTimer), 18)));
    draw_set_halign(fa_center);
}

// Screen iFrames
draw_set_color(c_white);
draw_set_alpha(1);
if (!global.frozen)
{
    if (global.flashTimer &gt; 0)
    {
        global.flashTimer -= 1;
        draw_sprite_ext(sprDot, image_index, view_xview, view_yview, view_wview, view_hview, image_angle, image_blend, image_alpha);
    }
}

draw_set_color(c_white);
draw_set_halign(fa_left);
draw_set_valign(fa_top);

if (fadeAlpha &gt; 0 &amp;&amp; !global.shadersEnabled)
{
    draw_sprite_ext(sprDot, 0, view_xview, view_yview, view_wview, view_hview, 0, c_black, fadeAlpha);
}

depth = depthstart;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// draw huds
if (showhealth)
{
    var dx = view_xview + 16;
    var dy = view_yview + 17;
    
    draw_enable_alphablend(false);
    
    /// Draw HUD
    for (var z = 0; z &lt; global.playerCount; z += 1)
    {
        draw_sprite_ext(sprHealthbarBackground, 0, dx, dy, 1, 1, image_angle,
            c_black, image_alpha);
        
        // Respawn indicators
        if (global.respawnTimer[z] &gt;= 0)
        {
            draw_set_color(c_white);
            draw_set_halign(fa_left);
            draw_set_valign(fa_middle);
            
            if (global.respawnTimer[z] &gt; 0)
            {
                draw_text(dx, dy + 28, ceil(global.respawnTimer[z] / 60));
            }
            else if (global.respawnAllowed)
            {
                draw_text(dx, dy + 28, "R#E#A#D#Y");
            }
            
            draw_set_valign(fa_top);
        }
        else
        {
            // normal healthbar
            var pcol = make_color_rgb(252, 228, 160);
            var scol = c_white;
            
            // low health -- red color
            if (global.playerHealth[z] &lt;= global.respawnDonateThreshold &amp;&amp; global.playerCount &gt; 1)
            {
                scol = pcol;
                pcol = global.nesPalette[5];
            }
            
            drawHudBar(dx, dy, pcol, scol, global.playerHealth[z], 28);
            
            // lives counter
            if (global.livesEnabled &amp;&amp; global.lifeCounter)
            {
                draw_enable_alphablend(true);
                draw_set_halign(fa_left);
                draw_set_valign(fa_top);
                draw_sprite_ext(sprDot, 0, dx, dy + sprite_get_height(sprHealthbarBackground), 8, 8, 0, c_black, 1);
                draw_text(dx, dy + sprite_get_height(sprHealthbarBackground), global.livesRemaining);
                draw_enable_alphablend(false);
            }
            
            // Weapons
            var display = true;
            
            var c
            if (global.weapon[z] != 0) // Weapon energy
            {
                c = round(global.ammo[z, global.weapon[z]]);
            }
            else // Charge bar
            {
                c = 0;
                with (objMegaman)
                {
                    if (playerID == z)
                    {
                        c = min(28, floor(chargeTimer) / 2);
                    }
                }
                display = global.chargeBar;
            }
            
            if (display)
            {
                draw_sprite_ext(sprHealthbarBackground, 0, dx - 8, dy, 1, 1,
                    image_angle, global.outlineCol[z], image_alpha);
                
                drawHudBar(dx - 8, dy, global.primaryCol[z],
                  global.secondaryCol[z], c, 28);
                
                if (global.infiniteEnergy[global.weapon[z]])
                {
                    draw_sprite_ext(sprInfinityMarkVertical, 0, dx - 8, dy + 28, 1,
                        1, 0, c_white, 1);
                    draw_sprite_ext(sprInfinityMarkVerticalPrimary, 0, dx - 8,
                        dy + 28, 1, 1, 0, global.primaryCol[z], 1);
                    draw_sprite_ext(sprInfinityMarkVerticalSecondary, 0, dx - 8,
                        dy + 28, 1, 1, 0, global.secondaryCol[z], 1);
                }
            }
        }
        
        dx += 24;
    }
    
    var bossFade = 0;
    var healthIndex = 0;
    with (prtBoss) // Boss healthbars
    {
        if (!quickSpawn&amp;&amp;drawHealthBar &amp;&amp; healthParent == -1)
        {
            var dxx = dx + ((healthIndex - 1) * 8); // Multibosses
            
            // Initial black bg for healthbar
            draw_sprite_ext(sprHealthbarBackground, 0, dxx, dy, 1, 1, 0, c_black, 1);
            
            // Choose color to draw
            var currentExtraHealthBar = 0;
            var bar_colors;
            var _currentHealth = 0;
            
            if (fillingHealthBar) //Intro health bar
            {
                _currentHealth = ceil(healthBarHealth);
            }
            else 
            {
                if (shareMode==1) //Combine health bars if needed
                {
                    with (prtBoss)
                    {
                        if (id == other.id || (healthParent==other.id &amp;&amp; drawHealthBar))
                        {
                            _currentHealth += healthpoints;
                        }
                    }
                }
                else
                {
                    _currentHealth = healthpoints;
                }
            }
            
            var bar_index = _currentHealth div 28;
            var bar_level = _currentHealth mod 28;
            
            if (1 &lt;= bar_index) {
              bar_colors = getBossHealthBarColors(bar_index);
              drawHudBar(dxx, dy, bar_colors[0], bar_colors[1], 28, 28);
            }
            
            if (0 &lt; bar_level) {
              bar_colors = getBossHealthBarColors(bar_index + 1);
              drawHudBar(dxx, dy, bar_colors[0], bar_colors[1], bar_level, 28);
            }
            
            healthIndex += 1;
        }
        
        if (isIntro &amp;&amp; introType == 3) // MM6 intro fading
        {
            bossFade = max(bossFade, introFade);
        }
    }
    
    draw_enable_alphablend(true);
    
    if (bossFade &gt; 0)
    {
        draw_sprite_ext(sprDot, 0, view_xview, view_yview, view_wview, view_hview, 0, c_black, bossFade);
    }
    
    // reset position
    var dx = view_xview + 16;
    var dy = view_yview + 17;
    
    // Keys
    for (i = 0; i &lt; global.keyNumber; i += 1)
    {
        draw_sprite_ext(sprKeyHud, 0, dx + 8, dy + (8 * i), 1, 1, 0, c_white, 1);
    }
    
    // Key coins
    for (i = 0; i &lt; global.keyCoinTotal; i += 1)
    {
        draw_sprite_ext(sprKeyCoinHUD, !(i &lt; global.keyCoinCollected),
            view_xview + (8 * i), view_yview + view_hview - 8, 1, 1, 0, c_white, 1);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
